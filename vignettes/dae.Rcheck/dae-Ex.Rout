
R version 3.6.1 (2019-07-05) -- "Action of the Toes"
Copyright (C) 2019 The R Foundation for Statistical Computing
Platform: x86_64-w64-mingw32/x64 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "dae"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> options(pager = "console")
> base::assign(".ExTimings", "dae-Ex.timings", pos = 'CheckExEnv')
> base::cat("name\tuser\tsystem\telapsed\n", file=base::get(".ExTimings", pos = 'CheckExEnv'))
> base::assign(".format_ptime",
+ function(x) {
+   if(!is.na(x[4L])) x[1L] <- x[1L] + x[4L]
+   if(!is.na(x[5L])) x[2L] <- x[2L] + x[5L]
+   options(OutDec = '.')
+   format(x[1L:3L], digits = 7L)
+ },
+ pos = 'CheckExEnv')
> 
> ### * </HEADER>
> library('dae')
Loading required package: ggplot2
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("Zncsspline")
> ### * Zncsspline
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: Zncsspline
> ### Title: Calculates the design matrix for fitting the random component of
> ###   a natural cubic smoothing spline
> ### Aliases: Zncsspline
> ### Keywords: array design
> 
> ### ** Examples
> 
> Z <- Zncsspline(knot.points = 1:10, Gpower = 0.5)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("Zncsspline", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("as.data.frame.pstructure")
> ### * as.data.frame.pstructure
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: as.data.frame.pstructure
> ### Title: Coerces a pstructure.object to a data.frame.
> ### Aliases: as.data.frame.pstructure
> ### Keywords: array projector
> 
> ### ** Examples
> 
> ## Generate a data.frame with 4 factors, each with three levels, in standard order
> ABCD.lay <- fac.gen(list(A = 3, B = 3, C = 3, D = 3))
> 
> ## create a pstructure object based on the formula ((A*B)/C)*D
> ABCD.struct <- pstructure.formula(~ ((A*B)/C)*D, data =ABCD.lay)
> 
> ## print the object either using the Method function or the generic function 
> ABCS.dat <- as.data.frame.pstructure(ABCD.struct)
> as.data.frame(ABCD.struct)
         df   terms  sources marginality.A marginality.B marginality.A.B
A         2       A        A             1             0               1
B         2       B        B             0             1               1
A#B       4     A:B      A#B             0             0               1
C[A:B]   18   A:B:C   C[A:B]             0             0               0
D         2       D        D             0             0               0
A#D       4     A:D      A#D             0             0               0
B#D       4     B:D      B#D             0             0               0
A#B#D     8   A:B:D    A#B#D             0             0               0
C#D[A:B] 36 A:B:C:D C#D[A:B]             0             0               0
         marginality.A.B.C marginality.D marginality.A.D marginality.B.D
A                        1             0               1               0
B                        1             0               0               1
A#B                      1             0               0               0
C[A:B]                   1             0               0               0
D                        0             1               1               1
A#D                      0             0               1               0
B#D                      0             0               0               1
A#B#D                    0             0               0               0
C#D[A:B]                 0             0               0               0
         marginality.A.B.D marginality.A.B.C.D
A                        1                   1
B                        1                   1
A#B                      1                   1
C[A:B]                   0                   1
D                        1                   1
A#D                      1                   1
B#D                      1                   1
A#B#D                    1                   1
C#D[A:B]                 0                   1
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("as.data.frame.pstructure", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("as.numfac")
> ### * as.numfac
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: as.numfac
> ### Title: Convert a factor to a numeric vector
> ### Aliases: as.numfac
> ### Keywords: factor manip
> 
> ### ** Examples
> 
> ## set up a factor and convert it to a numeric vector
> a <- factor(rep(1:3, 4))
> x <- as.numfac(a)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("as.numfac", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("blockboundaryPlot")
> ### * blockboundaryPlot
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: blockboundaryPlot
> ### Title: This function plots a block boundary on a plot produced by
> ###   'designPlot'.
> ### Aliases: blockboundaryPlot
> ### Keywords: design plot
> 
> ### ** Examples
> ## Not run: 
> ##D     SPL.Lines.mat <- matrix(as.numfac(Lines), ncol=16, byrow=T)
> ##D     colnames(SPL.Lines.mat) <- 1:16
> ##D     rownames(SPL.Lines.mat) <- 1:10
> ##D     SPL.Lines.mat <- SPL.Lines.mat[10:1, 1:16]
> ##D     designPlot(SPL.Lines.mat, labels=1:10, new=TRUE,
> ##D                rtitle="Rows",ctitle="Columns", 
> ##D                chardivisor=3, rcellpropn = 1, ccellpropn=1,
> ##D                plotcellboundary = TRUE)
> ##D     #Plot Mainplot boundaries
> ##D     blockboundaryPlot(blockdefinition = cbind(4,16), rstart = 1, 
> ##D                       blocklinewidth = 3, blockcolour = "green", 
> ##D                       nrows = 9, ncolumns = 16)
> ##D     blockboundaryPlot(blockdefinition = cbind(1,4), 
> ##D                       blocklinewidth = 3, blockcolour = "green", 
> ##D                       nrows = 1, ncolumns = 16)
> ##D     blockboundaryPlot(blockdefinition = cbind(1,4), rstart= 9, nrows = 10, ncolumns = 16, 
> ##D                       blocklinewidth = 3, blockcolour = "green")
> ##D     #Plot all 4 block boundaries            
> ##D     blockboundaryPlot(blockdefinition = cbind(8,5,5,4), blocksequence=T, 
> ##D                       cstart = 1, rstart= 1, nrows = 9, ncolumns = 15, 
> ##D                       blocklinewidth = 3,blockcolour = "blue")
> ##D     blockboundaryPlot(blockdefinition = cbind(10,16), blocklinewidth=3, blockcolour="blue", 
> ##D                       nrows=10, ncolumns=16)
> ##D     #Plot border and internal block boundaries only
> ##D     blockboundaryPlot(blockdefinition = cbind(8,14), cstart = 1, rstart= 1, 
> ##D                       nrows = 9, ncolumns =  15,
> ##D                       blocklinewidth = 3, blockcolour = "blue")
> ##D     blockboundaryPlot(blockdefinition = cbind(10,16), 
> ##D                       blocklinewidth = 3, blockcolour = "blue", 
> ##D                       nrows = 10, ncolumns = 16)
> ## End(Not run)
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("blockboundaryPlot", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("correct.degfree")
> ### * correct.degfree
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: correct.degfree
> ### Title: Check the degrees of freedom in an object of class projector
> ### Aliases: correct.degfree
> ### Keywords: array projector
> 
> ### ** Examples
> 
> ## set up a 2 x 2 mean operator that takes the mean of a vector of 2 values
> m <- matrix(rep(0.5,4), nrow=2)
> 
> ## create a projector based on the matrix m
> proj.m <- new("projector", data=m)
> 
> ## add its degrees of freedom
> degfree(proj.m) <- 1
>     
> ## check degrees of freedom are correct
> correct.degfree(proj.m)
[1] TRUE
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("correct.degfree", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("decomp.relate")
> ### * decomp.relate
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: decomp.relate
> ### Title: Examines the relationship between the eigenvectors for two
> ###   decompositions
> ### Aliases: decomp.relate
> ### Keywords: array design projector
> 
> ### ** Examples
> 
> ## PBIBD(2) from p. 379 of Cochran and Cox (1957) Experimental Designs. 
> ## 2nd edn Wiley, New York
> PBIBD2.unit <- list(Block = 6, Unit = 4)
> PBIBD2.nest <- list(Unit = "Block")
> trt <- factor(c(1,4,2,5, 2,5,3,6, 3,6,1,4, 4,1,5,2, 5,2,6,3, 6,3,4,1))
> PBIBD2.lay <- designRandomize(allocated = trt, 
+                               recipient = PBIBD2.unit, 
+                               nested.recipients = PBIBD2.nest)
> 
> ##obtain sets of projectors
> unit.struct <- pstructure(~ Block/Unit, data = PBIBD2.lay)
> trt.struct <- pstructure(~ trt, data = PBIBD2.lay)
> 
> ## obtain intra- and inter-block decompositions
> decomp.inter <- proj2.eigen(unit.struct$Q[["Block"]], trt.struct$Q[["trt"]])
> decomp.intra <- proj2.eigen(unit.struct$Q[["Unit[Block]"]], trt.struct$Q[["trt"]])
> 
> ## check that intra- and inter-block decompositions are orthogonal
> decomp.relate(decomp.intra, decomp.inter) 
     0.25 0.25
1       0    0
1       0    0
1       0    0
0.75    0    0
0.75    0    0
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("decomp.relate", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("degfree")
> ### * degfree
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: degfree
> ### Title: Degrees of freedom extraction and replacement
> ### Aliases: degfree degfree<-
> ### Keywords: array projector
> 
> ### ** Examples
> 
> ## set up a 2 x 2 mean operator that takes the mean of a vector of 2 values
> m <- matrix(rep(0.5,4), nrow=2)
> 
> ## coerce to a projector
> proj.m <- projector(m)
> 
> ## extract its degrees of freedom
> degfree(proj.m)
[1] 1
> 
> ## create a projector based on the matrix m
> proj.m <- new("projector", data=m)
> 
> ## add its degrees of freedom and print the projector
> degfree(proj.m) <- proj.m
> print(proj.m)
     [,1] [,2]
[1,]  0.5  0.5
[2,]  0.5  0.5
degfree:  1 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("degfree", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("designAmeasures")
> ### * designAmeasures
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: designAmeasures
> ### Title: Calculates the average variance of pairwise differences from the
> ###   variance matrix for predictions that can be obtained using
> ###   mat.Vpredicts
> ### Aliases: designAmeasures
> ### Keywords: design
> 
> ### ** Examples
> 
> ## Reduced example from Smith et al. (2015) 
> ## Generate two-phase design
> mill.fac <- fac.gen(list(Mrep = 2, Mday = 2, Mord = 3))
> field.lay <- fac.gen(list(Frep = 2, Fplot = 4))
> field.lay$Variety <- factor(c("D","E","Y","W","G","D","E","M"), 
+                             levels = c("Y","W","G","M","D","E"))
> start.design <- cbind(mill.fac, field.lay[c(3,4,5,8,1,7,3,4,5,8,6,2),])
> rownames(start.design) <- NULL
> 
> ## Set up matrices
> n <- nrow(start.design)
> W <- model.matrix(~ -1+ Variety, start.design)
> ng <- ncol(W)
> Gg<- diag(1, ng)
> Vu <- with(start.design, fac.vcmat(Mrep, 0.3) + 
+                          fac.vcmat(fac.combine(list(Mrep, Mday)), 0.2) + 
+                          fac.vcmat(Frep, 0.1) + 
+                          fac.vcmat(fac.combine(list(Frep, Fplot)), 0.2))
> R <- diag(1, n)
>   
> ## Calculate the varaince matrix of the predicted random Variety effects
> Vp <- mat.Vpred(W = W, Gg = Gg, Vu = Vu, R = R)
Warning in mat.Vpred(W = W, Gg = Gg, Vu = Vu, R = R) :
  mat.Vpred is superseded by mat.Vpredicts, being retained for backwards compatibility; it may be deprecated in future versions
>   
> ## Calculate A-optimality measure
> designAmeasures(Vp)
          all
all 0.8564816
> designAmeasures(Vp, groups=list(fldUndup = c(1:4), fldDup = c(5,6)))
          fldUndup    fldDup
fldUndup 0.8871287 0.8468064
fldDup   0.8468064 0.7500000
> grpsizes <- c(4,2)
> names(grpsizes) <- c("fldUndup", "fldDup")
> designAmeasures(Vp, groupsizes = grpsizes)
          fldUndup    fldDup
fldUndup 0.8871287 0.8468064
fldDup   0.8468064 0.7500000
> designAmeasures(Vp, groupsizes = c(4))
          [,1]
[1,] 0.8871287
> designAmeasures(Vp, groups=list(c(1,4),c(5,6)))
          [,1]      [,2]
[1,] 0.9309308 0.8305392
[2,] 0.8305392 0.7500000
> 
> ## Calculate the variance matrix of the predicted fixed Variety effects, elminating the grand mean
> Vp.reduc <- mat.Vpred(W = W, Gg = 0, Vu = Vu, R = R, 
+                       eliminate = projector(matrix(1, nrow = n, ncol = n)/n))
Warning in mat.Vpred(W = W, Gg = 0, Vu = Vu, R = R, eliminate = projector(matrix(1,  :
  mat.Vpred is superseded by mat.Vpredicts, being retained for backwards compatibility; it may be deprecated in future versions
> ## Calculate A-optimality measure
> designAmeasures(Vp.reduc)
         all
all 1.521495
> 
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("designAmeasures", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("designAnatomy")
> ### * designAnatomy
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: designAnatomy
> ### Title: Given the layout for a design, obtain its anatomy via the
> ###   canonical analysis of its projectors to show the confounding and
> ###   aliasing inherent in the design.
> ### Aliases: designAnatomy
> ### Keywords: array design projector
> 
> ### ** Examples
> 
> ## PBIBD(2) from p. 379 of Cochran and Cox (1957) Experimental Designs. 
> ## 2nd edn Wiley, New York
> PBIBD2.unit <- list(Block = 6, Unit = 4)
> PBIBD2.nest <- list(Unit = "Block")
> trt <- factor(c(1,4,2,5, 2,5,3,6, 3,6,1,4, 4,1,5,2, 5,2,6,3, 6,3,4,1))
> PBIBD2.lay <- designRandomize(allocated = trt, 
+                               recipient = PBIBD2.unit, 
+                               nested.recipients = PBIBD2.nest)
> 
> ##obtain combined decomposition and summarize
> unit.trt.canon <- designAnatomy(formulae = list(unit=~ Block/Unit, trt=~ trt),
+                                 data = PBIBD2.lay)
> summary(unit.trt.canon, which.criteria = c("aeff","eeff","order"))


Summary table of the decomposition for unit & trt (based on adjusted quantities)

 Source.unit df1 Source.trt df2 aefficiency eefficiency order
 Block         5 trt          2      0.2500      0.2500     1
                 Residual     3                              
 Unit[Block]  18 trt          5      0.8824      0.7500     2
                 Residual    13                              

The design is not orthogonal

> summary(unit.trt.canon, which.criteria = c("aeff","eeff","order"), labels.swap = TRUE)


Summary table of the decomposition for unit & trt (based on adjusted quantities)

 Term.unit  df1 Term.trt df2 aefficiency eefficiency order
 Block        5 trt        2      0.2500      0.2500     1
                Residual   3                              
 Block:Unit  18 trt        5      0.8824      0.7500     2
                Residual  13                              

The design is not orthogonal

> 
> ## Three-phase sensory example from Brien and Payne (1999)
> ## Not run: 
> ##D data(Sensory3Phase.dat)
> ##D Eval.Field.Treat.canon <- designAnatomy(formulae = list(
> ##D                               eval= ~ ((Occasions/Intervals/Sittings)*Judges)/Positions, 
> ##D                               field= ~ (Rows*(Squares/Columns))/Halfplots,
> ##D                               treats= ~ Trellis*Method),
> ##D                                         data = Sensory3Phase.dat)
> ##D summary(Eval.Field.Treat.canon, which.criteria =c("aefficiency", "order"))
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("designAnatomy", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("designBlocksGGPlot")
> ### * designBlocksGGPlot
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: designBlocksGGPlot
> ### Title: Adds block boundaries to a plot produced by 'designGGPlot'.
> ### Aliases: designBlocksGGPlot
> ### Keywords: design plot
> 
> ### ** Examples
> 
> ## Construct a randomized layout for the split-unit design described by 
> ## Brien et al. (2011, Section 5)
> split.sys <- cbind(fac.gen(list(Months = 4, Athletes = 3, Tests = 3)),
+                    fac.gen(list(Intensities = LETTERS[1:3], Surfaces = 3), 
+                            times = 4))
> split.lay <- designRandomize(allocated = split.sys[c("Intensities", "Surfaces")],
+                              recipient = split.sys[c("Months", "Athletes", "Tests")], 
+                              nested.recipients = list(Athletes = "Months", 
+                                                       Tests = c("Months", "Athletes")),
+                              seed = 2598)
> ## Plot the design
> cell.colours <- c("lightblue","lightcoral","lightgoldenrod","lightgreen","lightgrey",
+                   "lightpink","lightsalmon","lightcyan","lightyellow","lightseagreen")
> 
> split.lay <- within(split.lay, 
+                     Treatments <- fac.combine(list(Intensities, Surfaces), 
+                                               combine.levels = TRUE))
> plt <- designGGPlot(split.lay, labels = "Treatments", 
+                     row.factors = "Tests", column.factors = c("Months", "Athletes"),
+                     colour.values = cell.colours[1:9], size = 6, 
+                     blockdefinition = rbind(c(3,1)), blocklinecolour = "darkgreen",
+                     printPlot = FALSE)
> #Add Month boundaries
> designBlocksGGPlot(plt, nrows = 3, ncolumns = 3, blockdefinition = rbind(c(3,3)))
> 
> 
> 
> #### A layout for a growth cabinet experiment that allows for edge effects
> data(Cabinet1.des)
> plt <- designGGPlot(Cabinet1.des, labels = "Combinations", cellalpha = 0.75,
+                     title = "Lines and Harvests allocation for Cabinet 1", 
+                     printPlot = FALSE)
> 
> ## Plot Mainplot boundaries
> plt <- designBlocksGGPlot(plt, blockdefinition = cbind(4,16), originrow= 1 , 
+                           blocklinecolour = "green", nrows = 9, ncolumns = 16, 
+                           printPlot = FALSE)
> plt <- designBlocksGGPlot(plt, blockdefinition = cbind(1,4), 
+                           blocklinecolour = "green", nrows = 1, ncolumns = 16, 
+                           printPlot = FALSE)
> plt <- designBlocksGGPlot(plt, blockdefinition = cbind(1,4), originrow= 9, 
+                           blocklinecolour = "green", nrows = 10, ncolumns = 16, 
+                           printPlot = FALSE)
> ## Plot all 4 block boundaries            
> plt <- designBlocksGGPlot(plt, blockdefinition = cbind(8,5,5,4), blocksequence = TRUE, 
+                           origincolumn = 1, originrow= 1, 
+                           blocklinecolour = "blue", nrows = 9, ncolumns = 15, 
+                           printPlot = FALSE)
> plt <- designBlocksGGPlot(plt, blockdefinition = cbind(10,16), 
+                           blocklinecolour = "blue", nrows = 10, ncolumns = 16, 
+                           printPlot = FALSE)
> ## Plot border and internal block boundaries only
> plt <- designBlocksGGPlot(plt, blockdefinition = cbind(8,14), origincolumn = 1, originrow= 1, 
+                           blocklinecolour = "blue", nrows = 9, ncolumns = 15, 
+                           printPlot = FALSE)
> plt <- designBlocksGGPlot(plt, blockdefinition = cbind(10,16), 
+                           blocklinecolour = "blue", nrows = 10, ncolumns = 16)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("designBlocksGGPlot", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("designGGPlot")
> ### * designGGPlot
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: designGGPlot
> ### Title: Plots labels on two-way grids of coloured cells using 'ggplot2'
> ### Aliases: designGGPlot
> ### Keywords: aplot hplot design
> 
> ### ** Examples
> 
> #### Plot a randomized complete block design
> Treatments <- factor(rep(1:6, times = 5))
> RCBD.lay <- designRandomize(allocated = Treatments,
+                             recipient = list(Blocks = 5, Units = 6),
+                             nested.recipients = list(Units = "Blocks"),
+                             seed = 74111)
> designGGPlot(RCBD.lay, labels = "Treatments", size = 5, 
+              row.factors = "Blocks", column.factors = "Units", 
+              blockdefinition = cbind(1,5))
>              
> ## Plot without labels
> designGGPlot(RCBD.lay, cellfillcolour.column = "Treatments", 
+              row.factors = "Blocks", column.factors = "Units", 
+              colour.values = c("lightblue","lightcoral","lightgoldenrod",
+                                "lightgreen","lightgrey", "lightpink"), 
+              blockdefinition = cbind(1,6))
> 
>              
> #### Plot a lattice square design
> data(LatticeSquare_t49.des)
> designGGPlot(LatticeSquare_t49.des, labels = "Lines", size = 5, 
+              row.factors = c("Intervals", "Runs"), column.factors = "Times", 
+              blockdefinition = cbind(7,7))
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("designGGPlot", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("designLatinSqrSys")
> ### * designLatinSqrSys
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: designLatinSqrSys
> ### Title: Generate a systematic plan for a Latin Square design
> ### Aliases: designLatinSqrSys
> ### Keywords: array design
> 
> ### ** Examples
> 
>    matrix(designLatinSqrSys(5, start = c(seq(1, 5, 2), seq(2, 5, 2))), nrow=5)
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    3    5    2    4
[2,]    2    4    1    3    5
[3,]    3    5    2    4    1
[4,]    4    1    3    5    2
[5,]    5    2    4    1    3
>    designLatinSqrSys(3)
[1] 1 2 3 2 3 1 3 1 2
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("designLatinSqrSys", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("designPlot")
> ### * designPlot
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: designPlot
> ### Title: A graphical representation of an experimental design using
> ###   labels stored in a matrix.
> ### Aliases: designPlot
> ### Keywords: design plot
> 
> ### ** Examples
> ## Not run: 
> ##D   designPlot(des.mat, labels=1:4, cellfillcolour="lightblue", new=TRUE, 
> ##D              plotcellboundary = TRUE, chardivisor=3, 
> ##D              rtitle="Lanes", ctitle="Positions", 
> ##D              rcellpropn = 1, ccellpropn=1)
> ##D   designPlot(des.mat, labels=5:87, plotlabels=TRUE, cellfillcolour="grey", new=FALSE,
> ##D              plotcellboundary = TRUE, chardivisor=3)
> ##D   designPlot(des.mat, labels=88:434, plotlabels=TRUE, cellfillcolour="lightgreen", 
> ##D              new=FALSE, plotcellboundary = TRUE, chardivisor=3, 
> ##D              blocksequence=TRUE, blockdefinition=cbind(4,10,12), 
> ##D              blocklinewidth=3, blockcolour="blue")
> ## End(Not run)
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("designPlot", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("designPlotlabels")
> ### * designPlotlabels
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: designPlotlabels
> ### Title: Plots labels on a two-way grid using 'ggplot2'
> ### Aliases: designPlotlabels
> ### Keywords: aplot hplot design
> 
> ### ** Examples
> 
> Treatments <- factor(rep(1:6, times = 5))
> RCBD.lay <- designRandomize(allocated = Treatments,
+                             recipient = list(Blocks = 5, Units = 6),
+                             nested.recipients = list(Units = "Blocks"),
+                             seed = 74111)
> designPlotlabels(RCBD.lay, labels = "Treatments", 
+                  grid.x = "Units", grid.y = "Blocks",
+                  colour.column = "Treatments", size = 5)
Warning in designPlotlabels(RCBD.lay, labels = "Treatments", grid.x = "Units",  :
  designPlotlabels has been superseded by designGGPlot and will be deprecated in a future version
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("designPlotlabels", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("designRandomize")
> ### * designRandomize
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: designRandomize
> ### Title: Randomize allocated to recipient factors to produce a layout for
> ###   an experiment
> ### Aliases: designRandomize
> ### Keywords: design factor datagen
> 
> ### ** Examples
> 
> ## Generate a randomized layout for a 4 x 4 Latin square
> ## (the nested.recipients argument is not needed here as none of the 
> ## factors are nested)
> ## Firstly, generate a systematic layout
> LS.sys <- cbind(fac.gen(list(row = c("I","II","III","IV"), 
+                              col = c(0,2,4,6))),
+                 treat = factor(designLatinSqrSys(4), label = LETTERS[1:4]))
> ## obtain randomized layout
> LS.lay <- designRandomize(allocated = LS.sys["treat"], 
+                           recipient = LS.sys[c("row","col")], 
+                           seed = 7197132, unit.permutation = TRUE) 
> LS.lay[LS.lay$.Permutation,]
   .Units .Permutation row col treat
1       1            1   I   0     A
3       3            4   I   4     B
4       4            2   I   6     C
2       2            3   I   2     D
13     13            5  IV   0     B
15     15            8  IV   4     C
16     16            6  IV   6     D
14     14            7  IV   2     A
9       9            9 III   0     C
11     11           12 III   4     D
12     12           10 III   6     A
10     10           11 III   2     B
5       5           13  II   0     D
7       7           16  II   4     A
8       8           14  II   6     B
6       6           15  II   2     C
> 
> ## Generate a randomized layout for a replicated randomized complete 
> ## block design, with the block factors arranged in standard order for 
> ## rep then plot and then block
> ## Firstly, generate a systematic order such that levels of the 
> ## treatment factor coincide with plot
> RCBD.sys <- cbind(fac.gen(list(rep = 2, plot=1:3, block = c("I","II"))),
+                   tr = factor(rep(1:3, each=2, times=2)))
> ## obtain randomized layout
> RCBD.lay <- designRandomize(allocated = RCBD.sys["tr"], 
+                             recipient = RCBD.sys[c("rep", "block", "plot")], 
+                             nested.recipients = list(plot = c("block","rep"), 
+                                                      block="rep"), 
+                             seed = 9719532, 
+                             unit.permutation = TRUE)
> #sort into the original standard order
> RCBD.perm <- RCBD.lay[RCBD.lay$.Permutation,]
> #resort into randomized order
> RCBD.lay <- RCBD.perm[order(RCBD.perm$.Units),]
> 
> ## Generate a layout for a split-unit experiment in which: 
> ## - the main-unit factor is A with 4 levels arranged in 
> ##   a randomized complete block design with 2 blocks;
> ## - the split-unit factor is B with 3 levels.
> ## Firstly, generate a systematic layout
> SPL.sys <- cbind(fac.gen(list(block = 2, main.unit = 4, split.unit = 3)),
+                  fac.gen(list(A = 4, B = 3), times = 2))
> ## obtain randomized layout
> SPL.lay <- designRandomize(allocated = SPL.sys[c("A","B")], 
+                            recipient = SPL.sys[c("block", "main.unit", "split.unit")], 
+                            nested.recipients = list(main.unit = "block", 
+                                                     split.unit = c("block", "main.unit")), 
+                            seed=155251978)
> 
> ## Generate a permutation of Seedlings within Species
> seed.permute <- designRandomize(recipient = list(Species = 3, Seedlings = 4),
+                                 nested.recipients = list(Seedlings = "Species"),
+                                 seed = 75724, except = "Species", 
+                                 unit.permutation = TRUE)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("designRandomize", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("designTwophaseAnatomies")
> ### * designTwophaseAnatomies
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: designTwophaseAnatomies
> ### Title: Given the layout for a design and three structure formulae,
> ###   obtain the anatomies for the two-phase, first-phase, cross-phase and
> ###   second-phase designs.
> ### Aliases: designTwophaseAnatomies
> ### Keywords: array design projector
> 
> ### ** Examples
> 
>   #'## Microarray example from Jarrett & Ruggiero (2008) - see Brien (2019)
>   jr.lay <- fac.gen(list(Set = 7, Dye = 2, Array = 3))
>   jr.lay <- within(jr.lay, 
+                    { 
+                      Block <- factor(rep(1:7, each=6))
+                      Plant <- factor(rep(c(1,2,3,2,3,1), times=7))
+                      Sample <- factor(c(rep(c(2,1,2,2,1,1, 1,2,1,1,2,2), times=3), 
+                                         2,1,2,2,1,1))
+                      Treat <- factor(c(1,2,4,2,4,1, 2,3,5,3,5,2, 3,4,6,4,6,3, 
+                                        4,5,7,5,7,4, 5,6,1,6,1,5, 6,7,2,7,2,6, 
+                                        7,1,3,1,3,7),
+                                      labels=c("A","B","C","D","E","F","G"))
+                    })
>   
>   jr.anat <- designTwophaseAnatomies(formulae = list(array = ~ (Set:Array)*Dye,
+                                                      plot = ~ Block/Plant/Sample,
+                                                      trt = ~ Treat),
+                                      which.designs = c("first","cross"), 
+                                      data = jr.lay)  

### Anatomy for first-phase design


Summary table of the decomposition for plot & trt (based on adjusted quantities)

 Source.plot         df1 Source.trt df2 aefficiency eefficiency order
 Block                 6 Treat        6      0.2222      0.2222     1
 Plant[Block]         14 Treat        6      0.7778      0.7778     1
                         Residual     8                              
 Sample[Block:Plant]  21                                             

The design is not orthogonal


### Anatomy for cross-phase design


Summary table of the decomposition for array & trt (based on adjusted quantities)

 Source.array    df1 Source.trt df2 aefficiency eefficiency order
 Set:Array        20 Treat        6      0.4167      0.4167     1
                     Residual    14                              
 Dye               1                                             
 (Set:Array)#Dye  20 Treat        6      0.5833      0.5833     1
                     Residual    14                              

The design is not orthogonal

> 
> ## Three-phase sensory example from Brien and Payne (1999)
> ## Not run: 
> ##D data(Sensory3Phase.dat)
> ##D Sensory.canon <- designTwophaseAnatomies(formulae = list(
> ##D                               eval= ~ ((Occasions/Intervals/Sittings)*Judges)/Positions, 
> ##D                               field= ~ (Rows*(Squares/Columns))/Halfplots,
> ##D                               treats= ~ Trellis*Method),
> ##D                                         data = Sensory3Phase.dat)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("designTwophaseAnatomies", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("detect.diff")
> ### * detect.diff
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: detect.diff
> ### Title: Computes the detectable difference for an experiment
> ### Aliases: detect.diff
> ### Keywords: design
> 
> ### ** Examples
> 
> ## Compute the detectable difference for a randomized complete block design 
> ## with four treatments given power is 0.8 and alpha is 0.05. 
> rm <- 5
> detect.diff(rm = rm, df.num = 3, df.denom = 3 * (rm - 1),sigma = sqrt(20))
[1] 11.01565
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("detect.diff", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("efficiencies")
> ### * efficiencies
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: efficiencies
> ### Title: Extracts the canonical efficiency factors from a 'pcanon.object'
> ###   or a 'p2canon.object'.
> ### Aliases: efficiencies efficiencies.pcanon efficiencies.p2canon
> ### Keywords: array design projector
> 
> ### ** Examples
> 
> ## PBIBD(2) from p. 379 of Cochran and Cox (1957) Experimental Designs. 
> ## 2nd edn Wiley, New York
> PBIBD2.unit <- list(Block = 6, Unit = 4)
> PBIBD2.nest <- list(Unit = "Block")
> trt <- factor(c(1,4,2,5, 2,5,3,6, 3,6,1,4, 4,1,5,2, 5,2,6,3, 6,3,4,1))
> PBIBD2.lay <- designRandomize(allocated = trt, 
+                               recipient = PBIBD2.unit, 
+                               nested.recipients = PBIBD2.nest)
> 
> ##obtain combined decomposition using designAnatomy and get the efficiencies
> unit.trt.canon <- designAnatomy(list(unit=~ Block/Unit, trt=~ trt), data = PBIBD2.lay)
> efficiencies.pcanon(unit.trt.canon)
[[1]]
[[1]]$Block
[[1]]$Block$trt
[1] 0.25 0.25


[[1]]$`Unit[Block]`
[[1]]$`Unit[Block]`$trt
[1] 1.00 1.00 1.00 0.75 0.75



> 
> ##obtain the projectors for each formula using pstructure
> unit.struct <- pstructure(~ Block/Unit, data = PBIBD2.lay)
> trt.struct <- pstructure(~ trt, data = PBIBD2.lay)
> 
> ##obtain combined decomposition projs.2canon and get the efficiencies
> unit.trt.p2canon <- projs.2canon(unit.struct$Q, trt.struct$Q)
> efficiencies.p2canon(unit.trt.p2canon)
$Block
$Block$trt
[1] 0.25 0.25


$`Unit[Block]`
$`Unit[Block]`$trt
[1] 1.00 1.00 1.00 0.75 0.75


> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("efficiencies", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("efficiency.criteria")
> ### * efficiency.criteria
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: efficiency.criteria
> ### Title: Computes efficiency criteria from a set of efficiency factors
> ### Aliases: efficiency.criteria
> ### Keywords: array design projector
> 
> ### ** Examples
> 
> ## PBIBD(2) from p. 379 of Cochran and Cox (1957) Experimental Designs. 
> ## 2nd edn Wiley, New York
> PBIBD2.unit <- list(Block = 6, Unit = 4)
> PBIBD2.nest <- list(Unit = "Block")
> trt <- factor(c(1,4,2,5, 2,5,3,6, 3,6,1,4, 4,1,5,2, 5,2,6,3, 6,3,4,1))
> PBIBD2.lay <- designRandomize(allocated = trt, 
+                               recipient = PBIBD2.unit, 
+                               nested.recipients = PBIBD2.nest)
> 
> ## obtain sets of projectors
> unit.struct <- pstructure(~ Block/Unit, data = PBIBD2.lay)
> trt.struct <- pstructure(~ trt, data = PBIBD2.lay)
> 
> ## save intrablock efficiencies
> eff.inter <- proj2.efficiency(unit.struct$Q[["Unit[Block]"]], trt.struct$Q[["trt"]])
> 
> ## calculate efficiency criteria
> efficiency.criteria(eff.inter)
$aefficiency
[1] 0.8823529

$mefficiency
[1] 0.9

$sefficiency
[1] 0.01875

$eefficiency
[1] 0.75

$xefficiency
[1] 1

$order
[1] 2

$dforthog
[1] 3

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("efficiency.criteria", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("elements")
> ### * elements
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: elements
> ### Title: Extract the elements of an array specified by the subscripts
> ### Aliases: elements
> ### Keywords: array manip
> 
> ### ** Examples
> 
> ## Form a table of the means for all combinations of Row and Line.
> ## Then obtain the values corresponding to the combinations in the data frame x,
> ## excluding Row 3.
> x <- fac.gen(list(Row = 2, Line = 4), each =2)
> x$y <- rnorm(16)
> RowLine.tab <- tapply(x$y, list(x$Row, x$Line), mean)
> xs <- elements(RowLine.tab, subscripts=x[x$"Line" != 3, c("Row", "Line")])
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("elements", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("extab")
> ### * extab
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: extab
> ### Title: Expands the values in table to a vector
> ### Aliases: extab
> ### Keywords: manip
> 
> ### ** Examples
> 
> ## generate a small completely randomized design with the two-level 
> ## factors A and B 
> n <- 12
> CRD.unit <- list(Unit = n)
> CRD.treat <- fac.gen(list(A = 2, B = 2), each = 3)
> CRD.lay <- designRandomize(allocated = CRD.treat, recipient = CRD.unit, 
+                            seed = 956)
> 
> ## set up a 2 x 2 table of A x B effects	
> AB.tab <- c(12, -12, -12, 12)
> 
> ## add a unit-length vector of expanded effects to CRD.lay
> attach(CRD.lay)
> CRD.lay$AB.effects <- extab(table=AB.tab, index.factors=list(A, B))
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("extab", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching 'CRD.lay'

> nameEx("fac.ar1mat")
> ### * fac.ar1mat
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: fac.ar1mat
> ### Title: forms the ar1 correlation matrix for a (generalized) factor
> ### Aliases: fac.ar1mat
> ### Keywords: array
> 
> ### ** Examples
> 
> ## set up a two-level factor and a three-level factor, both of length 12
> A <- factor(rep(1:2, each=6))
> B <- factor(rep(1:3, each=2, times=2))
> 
> ## create a 12 x 12 ar1 matrix corrresponding to B
> ar1.B <- fac.ar1mat(B, 0.6)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("fac.ar1mat", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("fac.combine")
> ### * fac.combine
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: fac.combine
> ### Title: Combines several factors into one
> ### Aliases: fac.combine
> ### Keywords: factor manip
> 
> ### ** Examples
> 
> ## set up two factors
> A <- factor(rep(1:2, each=6))
> B <- factor(rep(1:3, each=2, times=2))
> 
> ## obtain six-level factor corresponding to the combinations of A and B
> AB <- fac.combine(list(A,B))
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("fac.combine", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("fac.divide")
> ### * fac.divide
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: fac.divide
> ### Title: Divides a factor into several individual factors
> ### Aliases: fac.divide
> ### Keywords: factor manip
> 
> ### ** Examples
> 
> ## generate a small completely randomized design for 6 treatments 
> n <- 12
> CRD.unit <- list(Unit = n)
> treat <- factor(rep(1:4, each = 3))
> CRD.lay <- designRandomize(allocated = treat, recipient = CRD.unit, seed=956)
> 
> ## divide the treatments into two two-level factor A nd B
> CRD.facs <- fac.divide(CRD.lay$treat, factor.names = list(A = 2, B = 2))
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("fac.divide", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("fac.gen")
> ### * fac.gen
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: fac.gen
> ### Title: Generate all combinations of several factors and, optionally,
> ###   replicate them
> ### Aliases: fac.gen
> ### Keywords: design factor datagen
> 
> ### ** Examples
> 
> ## generate a 2^3 factorial experiment with levels - and +, and 
> ## in Yates order
> mp <- c("-", "+")
> fnames <- list(Catal = mp, Temp = mp, Press = mp, Conc = mp)
> Fac4Proc.Treats <- fac.gen(generate = fnames, order="yates")
> 
> ## Generate the factors A, B and D. The basic pattern has 4 repetitions
> ## of the levels of D for each A and B combination and 3 repetitions of 
> ## the pattern of the B and D combinations for each level of A. This basic 
> ## pattern has each combination repeated twice, and the whole of this 
> ## is repeated twice. It generates 864 A, B and D combinations.
> gen <- list(A = 3, 3, B = c(0,100,200), 4, D = c("0","1"))
> fac.gen(gen, times=2, each=2)
    A   B D
1   1   0 0
2   1   0 0
3   1   0 1
4   1   0 1
5   1   0 0
6   1   0 0
7   1   0 1
8   1   0 1
9   1   0 0
10  1   0 0
11  1   0 1
12  1   0 1
13  1   0 0
14  1   0 0
15  1   0 1
16  1   0 1
17  1 100 0
18  1 100 0
19  1 100 1
20  1 100 1
21  1 100 0
22  1 100 0
23  1 100 1
24  1 100 1
25  1 100 0
26  1 100 0
27  1 100 1
28  1 100 1
29  1 100 0
30  1 100 0
31  1 100 1
32  1 100 1
33  1 200 0
34  1 200 0
35  1 200 1
36  1 200 1
37  1 200 0
38  1 200 0
39  1 200 1
40  1 200 1
41  1 200 0
42  1 200 0
43  1 200 1
44  1 200 1
45  1 200 0
46  1 200 0
47  1 200 1
48  1 200 1
49  1   0 0
50  1   0 0
51  1   0 1
52  1   0 1
53  1   0 0
54  1   0 0
55  1   0 1
56  1   0 1
57  1   0 0
58  1   0 0
59  1   0 1
60  1   0 1
61  1   0 0
62  1   0 0
63  1   0 1
64  1   0 1
65  1 100 0
66  1 100 0
67  1 100 1
68  1 100 1
69  1 100 0
70  1 100 0
71  1 100 1
72  1 100 1
73  1 100 0
74  1 100 0
75  1 100 1
76  1 100 1
77  1 100 0
78  1 100 0
79  1 100 1
80  1 100 1
81  1 200 0
82  1 200 0
83  1 200 1
84  1 200 1
85  1 200 0
86  1 200 0
87  1 200 1
88  1 200 1
89  1 200 0
90  1 200 0
91  1 200 1
92  1 200 1
93  1 200 0
94  1 200 0
95  1 200 1
96  1 200 1
97  1   0 0
98  1   0 0
99  1   0 1
100 1   0 1
101 1   0 0
102 1   0 0
103 1   0 1
104 1   0 1
105 1   0 0
106 1   0 0
107 1   0 1
108 1   0 1
109 1   0 0
110 1   0 0
111 1   0 1
112 1   0 1
113 1 100 0
114 1 100 0
115 1 100 1
116 1 100 1
117 1 100 0
118 1 100 0
119 1 100 1
120 1 100 1
121 1 100 0
122 1 100 0
123 1 100 1
124 1 100 1
125 1 100 0
126 1 100 0
127 1 100 1
128 1 100 1
129 1 200 0
130 1 200 0
131 1 200 1
132 1 200 1
133 1 200 0
134 1 200 0
135 1 200 1
136 1 200 1
137 1 200 0
138 1 200 0
139 1 200 1
140 1 200 1
141 1 200 0
142 1 200 0
143 1 200 1
144 1 200 1
145 2   0 0
146 2   0 0
147 2   0 1
148 2   0 1
149 2   0 0
150 2   0 0
151 2   0 1
152 2   0 1
153 2   0 0
154 2   0 0
155 2   0 1
156 2   0 1
157 2   0 0
158 2   0 0
159 2   0 1
160 2   0 1
161 2 100 0
162 2 100 0
163 2 100 1
164 2 100 1
165 2 100 0
166 2 100 0
167 2 100 1
168 2 100 1
169 2 100 0
170 2 100 0
171 2 100 1
172 2 100 1
173 2 100 0
174 2 100 0
175 2 100 1
176 2 100 1
177 2 200 0
178 2 200 0
179 2 200 1
180 2 200 1
181 2 200 0
182 2 200 0
183 2 200 1
184 2 200 1
185 2 200 0
186 2 200 0
187 2 200 1
188 2 200 1
189 2 200 0
190 2 200 0
191 2 200 1
192 2 200 1
193 2   0 0
194 2   0 0
195 2   0 1
196 2   0 1
197 2   0 0
198 2   0 0
199 2   0 1
200 2   0 1
201 2   0 0
202 2   0 0
203 2   0 1
204 2   0 1
205 2   0 0
206 2   0 0
207 2   0 1
208 2   0 1
209 2 100 0
210 2 100 0
211 2 100 1
212 2 100 1
213 2 100 0
214 2 100 0
215 2 100 1
216 2 100 1
217 2 100 0
218 2 100 0
219 2 100 1
220 2 100 1
221 2 100 0
222 2 100 0
223 2 100 1
224 2 100 1
225 2 200 0
226 2 200 0
227 2 200 1
228 2 200 1
229 2 200 0
230 2 200 0
231 2 200 1
232 2 200 1
233 2 200 0
234 2 200 0
235 2 200 1
236 2 200 1
237 2 200 0
238 2 200 0
239 2 200 1
240 2 200 1
241 2   0 0
242 2   0 0
243 2   0 1
244 2   0 1
245 2   0 0
246 2   0 0
247 2   0 1
248 2   0 1
249 2   0 0
250 2   0 0
251 2   0 1
252 2   0 1
253 2   0 0
254 2   0 0
255 2   0 1
256 2   0 1
257 2 100 0
258 2 100 0
259 2 100 1
260 2 100 1
261 2 100 0
262 2 100 0
263 2 100 1
264 2 100 1
265 2 100 0
266 2 100 0
267 2 100 1
268 2 100 1
269 2 100 0
270 2 100 0
271 2 100 1
272 2 100 1
273 2 200 0
274 2 200 0
275 2 200 1
276 2 200 1
277 2 200 0
278 2 200 0
279 2 200 1
280 2 200 1
281 2 200 0
282 2 200 0
283 2 200 1
284 2 200 1
285 2 200 0
286 2 200 0
287 2 200 1
288 2 200 1
289 3   0 0
290 3   0 0
291 3   0 1
292 3   0 1
293 3   0 0
294 3   0 0
295 3   0 1
296 3   0 1
297 3   0 0
298 3   0 0
299 3   0 1
300 3   0 1
301 3   0 0
302 3   0 0
303 3   0 1
304 3   0 1
305 3 100 0
306 3 100 0
307 3 100 1
308 3 100 1
309 3 100 0
310 3 100 0
311 3 100 1
312 3 100 1
313 3 100 0
314 3 100 0
315 3 100 1
316 3 100 1
317 3 100 0
318 3 100 0
319 3 100 1
320 3 100 1
321 3 200 0
322 3 200 0
323 3 200 1
324 3 200 1
325 3 200 0
326 3 200 0
327 3 200 1
328 3 200 1
329 3 200 0
330 3 200 0
331 3 200 1
332 3 200 1
333 3 200 0
334 3 200 0
335 3 200 1
336 3 200 1
337 3   0 0
338 3   0 0
339 3   0 1
340 3   0 1
341 3   0 0
342 3   0 0
343 3   0 1
344 3   0 1
345 3   0 0
346 3   0 0
347 3   0 1
348 3   0 1
349 3   0 0
350 3   0 0
351 3   0 1
352 3   0 1
353 3 100 0
354 3 100 0
355 3 100 1
356 3 100 1
357 3 100 0
358 3 100 0
359 3 100 1
360 3 100 1
361 3 100 0
362 3 100 0
363 3 100 1
364 3 100 1
365 3 100 0
366 3 100 0
367 3 100 1
368 3 100 1
369 3 200 0
370 3 200 0
371 3 200 1
372 3 200 1
373 3 200 0
374 3 200 0
375 3 200 1
376 3 200 1
377 3 200 0
378 3 200 0
379 3 200 1
380 3 200 1
381 3 200 0
382 3 200 0
383 3 200 1
384 3 200 1
385 3   0 0
386 3   0 0
387 3   0 1
388 3   0 1
389 3   0 0
390 3   0 0
391 3   0 1
392 3   0 1
393 3   0 0
394 3   0 0
395 3   0 1
396 3   0 1
397 3   0 0
398 3   0 0
399 3   0 1
400 3   0 1
401 3 100 0
402 3 100 0
403 3 100 1
404 3 100 1
405 3 100 0
406 3 100 0
407 3 100 1
408 3 100 1
409 3 100 0
410 3 100 0
411 3 100 1
412 3 100 1
413 3 100 0
414 3 100 0
415 3 100 1
416 3 100 1
417 3 200 0
418 3 200 0
419 3 200 1
420 3 200 1
421 3 200 0
422 3 200 0
423 3 200 1
424 3 200 1
425 3 200 0
426 3 200 0
427 3 200 1
428 3 200 1
429 3 200 0
430 3 200 0
431 3 200 1
432 3 200 1
433 1   0 0
434 1   0 0
435 1   0 1
436 1   0 1
437 1   0 0
438 1   0 0
439 1   0 1
440 1   0 1
441 1   0 0
442 1   0 0
443 1   0 1
444 1   0 1
445 1   0 0
446 1   0 0
447 1   0 1
448 1   0 1
449 1 100 0
450 1 100 0
451 1 100 1
452 1 100 1
453 1 100 0
454 1 100 0
455 1 100 1
456 1 100 1
457 1 100 0
458 1 100 0
459 1 100 1
460 1 100 1
461 1 100 0
462 1 100 0
463 1 100 1
464 1 100 1
465 1 200 0
466 1 200 0
467 1 200 1
468 1 200 1
469 1 200 0
470 1 200 0
471 1 200 1
472 1 200 1
473 1 200 0
474 1 200 0
475 1 200 1
476 1 200 1
477 1 200 0
478 1 200 0
479 1 200 1
480 1 200 1
481 1   0 0
482 1   0 0
483 1   0 1
484 1   0 1
485 1   0 0
486 1   0 0
487 1   0 1
488 1   0 1
489 1   0 0
490 1   0 0
491 1   0 1
492 1   0 1
493 1   0 0
494 1   0 0
495 1   0 1
496 1   0 1
497 1 100 0
498 1 100 0
499 1 100 1
500 1 100 1
501 1 100 0
502 1 100 0
503 1 100 1
504 1 100 1
505 1 100 0
506 1 100 0
507 1 100 1
508 1 100 1
509 1 100 0
510 1 100 0
511 1 100 1
512 1 100 1
513 1 200 0
514 1 200 0
515 1 200 1
516 1 200 1
517 1 200 0
518 1 200 0
519 1 200 1
520 1 200 1
521 1 200 0
522 1 200 0
523 1 200 1
524 1 200 1
525 1 200 0
526 1 200 0
527 1 200 1
528 1 200 1
529 1   0 0
530 1   0 0
531 1   0 1
532 1   0 1
533 1   0 0
534 1   0 0
535 1   0 1
536 1   0 1
537 1   0 0
538 1   0 0
539 1   0 1
540 1   0 1
541 1   0 0
542 1   0 0
543 1   0 1
544 1   0 1
545 1 100 0
546 1 100 0
547 1 100 1
548 1 100 1
549 1 100 0
550 1 100 0
551 1 100 1
552 1 100 1
553 1 100 0
554 1 100 0
555 1 100 1
556 1 100 1
557 1 100 0
558 1 100 0
559 1 100 1
560 1 100 1
561 1 200 0
562 1 200 0
563 1 200 1
564 1 200 1
565 1 200 0
566 1 200 0
567 1 200 1
568 1 200 1
569 1 200 0
570 1 200 0
571 1 200 1
572 1 200 1
573 1 200 0
574 1 200 0
575 1 200 1
576 1 200 1
577 2   0 0
578 2   0 0
579 2   0 1
580 2   0 1
581 2   0 0
582 2   0 0
583 2   0 1
584 2   0 1
585 2   0 0
586 2   0 0
587 2   0 1
588 2   0 1
589 2   0 0
590 2   0 0
591 2   0 1
592 2   0 1
593 2 100 0
594 2 100 0
595 2 100 1
596 2 100 1
597 2 100 0
598 2 100 0
599 2 100 1
600 2 100 1
601 2 100 0
602 2 100 0
603 2 100 1
604 2 100 1
605 2 100 0
606 2 100 0
607 2 100 1
608 2 100 1
609 2 200 0
610 2 200 0
611 2 200 1
612 2 200 1
613 2 200 0
614 2 200 0
615 2 200 1
616 2 200 1
617 2 200 0
618 2 200 0
619 2 200 1
620 2 200 1
621 2 200 0
622 2 200 0
623 2 200 1
624 2 200 1
625 2   0 0
626 2   0 0
627 2   0 1
628 2   0 1
629 2   0 0
630 2   0 0
631 2   0 1
632 2   0 1
633 2   0 0
634 2   0 0
635 2   0 1
636 2   0 1
637 2   0 0
638 2   0 0
639 2   0 1
640 2   0 1
641 2 100 0
642 2 100 0
643 2 100 1
644 2 100 1
645 2 100 0
646 2 100 0
647 2 100 1
648 2 100 1
649 2 100 0
650 2 100 0
651 2 100 1
652 2 100 1
653 2 100 0
654 2 100 0
655 2 100 1
656 2 100 1
657 2 200 0
658 2 200 0
659 2 200 1
660 2 200 1
661 2 200 0
662 2 200 0
663 2 200 1
664 2 200 1
665 2 200 0
666 2 200 0
667 2 200 1
668 2 200 1
669 2 200 0
670 2 200 0
671 2 200 1
672 2 200 1
673 2   0 0
674 2   0 0
675 2   0 1
676 2   0 1
677 2   0 0
678 2   0 0
679 2   0 1
680 2   0 1
681 2   0 0
682 2   0 0
683 2   0 1
684 2   0 1
685 2   0 0
686 2   0 0
687 2   0 1
688 2   0 1
689 2 100 0
690 2 100 0
691 2 100 1
692 2 100 1
693 2 100 0
694 2 100 0
695 2 100 1
696 2 100 1
697 2 100 0
698 2 100 0
699 2 100 1
700 2 100 1
701 2 100 0
702 2 100 0
703 2 100 1
704 2 100 1
705 2 200 0
706 2 200 0
707 2 200 1
708 2 200 1
709 2 200 0
710 2 200 0
711 2 200 1
712 2 200 1
713 2 200 0
714 2 200 0
715 2 200 1
716 2 200 1
717 2 200 0
718 2 200 0
719 2 200 1
720 2 200 1
721 3   0 0
722 3   0 0
723 3   0 1
724 3   0 1
725 3   0 0
726 3   0 0
727 3   0 1
728 3   0 1
729 3   0 0
730 3   0 0
731 3   0 1
732 3   0 1
733 3   0 0
734 3   0 0
735 3   0 1
736 3   0 1
737 3 100 0
738 3 100 0
739 3 100 1
740 3 100 1
741 3 100 0
742 3 100 0
743 3 100 1
744 3 100 1
745 3 100 0
746 3 100 0
747 3 100 1
748 3 100 1
749 3 100 0
750 3 100 0
751 3 100 1
752 3 100 1
753 3 200 0
754 3 200 0
755 3 200 1
756 3 200 1
757 3 200 0
758 3 200 0
759 3 200 1
760 3 200 1
761 3 200 0
762 3 200 0
763 3 200 1
764 3 200 1
765 3 200 0
766 3 200 0
767 3 200 1
768 3 200 1
769 3   0 0
770 3   0 0
771 3   0 1
772 3   0 1
773 3   0 0
774 3   0 0
775 3   0 1
776 3   0 1
777 3   0 0
778 3   0 0
779 3   0 1
780 3   0 1
781 3   0 0
782 3   0 0
783 3   0 1
784 3   0 1
785 3 100 0
786 3 100 0
787 3 100 1
788 3 100 1
789 3 100 0
790 3 100 0
791 3 100 1
792 3 100 1
793 3 100 0
794 3 100 0
795 3 100 1
796 3 100 1
797 3 100 0
798 3 100 0
799 3 100 1
800 3 100 1
801 3 200 0
802 3 200 0
803 3 200 1
804 3 200 1
805 3 200 0
806 3 200 0
807 3 200 1
808 3 200 1
809 3 200 0
810 3 200 0
811 3 200 1
812 3 200 1
813 3 200 0
814 3 200 0
815 3 200 1
816 3 200 1
817 3   0 0
818 3   0 0
819 3   0 1
820 3   0 1
821 3   0 0
822 3   0 0
823 3   0 1
824 3   0 1
825 3   0 0
826 3   0 0
827 3   0 1
828 3   0 1
829 3   0 0
830 3   0 0
831 3   0 1
832 3   0 1
833 3 100 0
834 3 100 0
835 3 100 1
836 3 100 1
837 3 100 0
838 3 100 0
839 3 100 1
840 3 100 1
841 3 100 0
842 3 100 0
843 3 100 1
844 3 100 1
845 3 100 0
846 3 100 0
847 3 100 1
848 3 100 1
849 3 200 0
850 3 200 0
851 3 200 1
852 3 200 1
853 3 200 0
854 3 200 0
855 3 200 1
856 3 200 1
857 3 200 0
858 3 200 0
859 3 200 1
860 3 200 1
861 3 200 0
862 3 200 0
863 3 200 1
864 3 200 1
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("fac.gen", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("fac.match")
> ### * fac.match
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: fac.match
> ### Title: Match, for each combination of a set of columns in 'x', the row
> ###   that has the same combination in 'table'
> ### Aliases: fac.match
> ### Keywords: design factor
> 
> ### ** Examples
> ## Not run: 
> ##D #A single unmatched combination
> ##D kdata <- data.frame(Expt="D197-5", 
> ##D                     Row=8, 
> ##D                     Column=20, stringsAsFactors=FALSE)
> ##D index <- fac.match(kdata, D197.dat, c("Expt", "Row", "Column"))
> ##D 
> ##D # A matched and an unmatched combination
> ##D kdata <- data.frame(Expt=c("D197-5", "D197-4"), 
> ##D                     Row=c(8, 10), 
> ##D                     Column=c(20, 8), stringsAsFactors=FALSE)
> ##D index <- fac.match(kdata, D197.dat, c("Expt", "Row", "Column"))
> ## End(Not run)
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("fac.match", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("fac.meanop")
> ### * fac.meanop
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: fac.meanop
> ### Title: computes the projection matrix that produces means
> ### Aliases: fac.meanop
> ### Keywords: array projector
> 
> ### ** Examples
> 
> ## set up a two-level factor and a three-level factor, both of length 12
> A <- factor(rep(1:2, each=6))
> B <- factor(rep(1:3, each=2, times=2))
> 
> ## create a generalized factor whose levels are the combinations of A and B
> AB <- fac.combine(list(A,B))
> 
> ## obtain the operator that computes the AB means from a vector of length 12
> M.AB <- fac.meanop(AB)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("fac.meanop", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("fac.multinested")
> ### * fac.multinested
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: fac.multinested
> ### Title: Creates several factors, one for each level of nesting.fac and
> ###   each of whose values are either generated within those of a level of
> ###   nesting.fac or using the values of nested.fac within a levels of
> ###   nesting.fac.
> ### Aliases: fac.multinested
> ### Keywords: factor manip
> 
> ### ** Examples
> 
>   lay <- data.frame(A = factor(rep(c(1:3), c(3,6,4)), labels = letters[1:3]))
>   lay$B <-fac.nested(lay$A)
> 
>   #Add factors for B within each level of A
>   lay2 <- cbind(lay, fac.multinested(lay$A))
>   canon2 <- designAnatomy(list(~A/(a+b+c)), data = lay2)
>   summary(canon2)


Summary table of the decomposition

 Source  df
 A        2
 a[A]     2
 b[A]     5
 c[A]     3
> 
>   #Add factors for B within each level of A, but with levels and outlabel given
>   lay2 <- cbind(lay, fac.multinested(lay$A, nested.levs = seq(10,60,10), outlabel = "other"))
>   canon2 <- designAnatomy(list(~A/(a+b+c)), data = lay2)
>   summary(canon2)


Summary table of the decomposition

 Source  df
 A        2
 a[A]     2
 b[A]     5
 c[A]     3
> 
>   #Replicate the combinations of A and B three times and index them with the factor sample
>   lay3 <- rbind(lay,lay,lay)
>   lay3$sample <- with(lay3, fac.nested(fac.combine(list(A,B))))
>   
>   #Add factors for B within each level of A
>   lay4 <- cbind(lay3, fac.multinested(nesting.fac = lay$A, nested.fac = lay$B))
>   canon4 <- designAnatomy(list(~(A/(a+b+c))/sample), data = lay4)
>   summary(canon4)


Summary table of the decomposition

 Source           df
 A                 2
 a[A]              2
 b[A]              5
 c[A]              3
 a#b#c#sample[A]  26
> 
>   #Add factors for sample within each combination of A and B
>   lay5 <- with(lay4, cbind(lay4, 
+                            fac.multinested(nesting.fac = a, fac.prefix = "a"),
+                            fac.multinested(nesting.fac = b, fac.prefix = "b"),
+                            fac.multinested(nesting.fac = c, fac.prefix = "c")))
> 
>   #Add factors for sample within each level of A
>   lay6 <- cbind(lay4, 
+                 fac.multinested(nesting.fac = lay4$A, nested.fac = lay$sample, fac.prefix = "samp"))
>   canon6 <- designAnatomy(list(~A/(a/sampa+b/sampb+c/sampc)), data = lay6)
>   summary(canon6)


Summary table of the decomposition

 Source      df
 A            2
 a[A]         2
 sampa[A:a]   6
 b[A]         5
 sampb[A:b]  12
 c[A]         3
 sampc[A:c]   8
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("fac.multinested", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("fac.nested")
> ### * fac.nested
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: fac.nested
> ### Title: creates a factor, the nested factor, whose values are generated
> ###   within those of the factor nesting.fac
> ### Aliases: fac.nested
> ### Keywords: factor manip
> 
> ### ** Examples
> 
> ## set up factor A
> A <- factor(c(1, 1, 1, 2, 2))
> 
> ## create nested factor
> B <- fac.nested(A)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("fac.nested", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("fac.recode")
> ### * fac.recode
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: fac.recode
> ### Title: Recodes factor 'levels' using values in a vector. The values in
> ###   the vector do not have to be unique.
> ### Aliases: fac.recode
> ### Keywords: factor manip
> 
> ### ** Examples
> 
> ## set up a factor with labels
> a <- factor(rep(1:4, 4), labels=c("A","B","C","D"))
>  
> ## recode "A" and "D" to 1 and "B" and "C" to 2
> b <- fac.recode(a, c(1,2,2,1), labels = c("a","b"))
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("fac.recode", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("fac.sumop")
> ### * fac.sumop
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: fac.sumop
> ### Title: computes the summation matrix that produces sums corresponding
> ###   to a (generalized) factor
> ### Aliases: fac.sumop
> ### Keywords: array projector
> 
> ### ** Examples
> 
> ## set up a two-level factoir and a three-level factor, both of length 12
> A <- factor(rep(1:2, each=6))
> B <- factor(rep(1:3, each=2, times=2))
> 
> ## create a generlaized factor whose levels are the combinations of A and B
> AB <- fac.combine(list(A,B))
> 
> ## obtain the operator that computes the AB means from a vector of length 12
> S.AB <- fac.sumop(AB)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("fac.sumop", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("fac.vcmat")
> ### * fac.vcmat
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: fac.vcmat
> ### Title: forms the variance matrix for the variance component of a
> ###   (generalized) factor
> ### Aliases: fac.vcmat
> ### Keywords: array
> 
> ### ** Examples
> 
> ## set up a two-level factor and a three-level factor, both of length 12
> A <- factor(rep(1:2, each=6))
> B <- factor(rep(1:3, each=2, times=2))
> 
> ## create a 12 x 12 ar1 matrix corrresponding to B
> vc.B <- fac.vcmat(B, 2)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("fac.vcmat", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("fitted.aovlist")
> ### * fitted.aovlist
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: fitted.aovlist
> ### Title: Extract the fitted values for a fitted model from an aovlist
> ###   object
> ### Aliases: fitted.aovlist fitted
> ### Keywords: methods models htest
> 
> ### ** Examples
> 
> ## set up data frame for randomized complete block design in Table 4.4 from 
> ## Box, Hunter and Hunter (2005) Statistics for Experimenters. 2nd edn 
> ## New York, Wiley.
> RCBDPen.dat <- fac.gen(list(Blend=5, Flask=4))
> RCBDPen.dat$Treat <- factor(rep(c("A","B","C","D"), times=5))
> RCBDPen.dat$Yield <- c(89,88,97,94,84,77,92,79,81,87,87,
+                        85,87,92,89,84,79,81,80,88)
> 
> ## perform the analysis of variance
> RCBDPen.aov <- aov(Yield ~ Blend + Treat + Error(Blend/Flask), RCBDPen.dat)
> summary(RCBDPen.aov)

Error: Blend
      Df Sum Sq Mean Sq
Blend  4    264      66

Error: Blend:Flask
          Df Sum Sq Mean Sq F value Pr(>F)
Treat      3     70   23.33   1.239  0.339
Residuals 12    226   18.83               
> 
> ## two equivalent ways of extracting the fitted values
> fit  <- fitted.aovlist(RCBDPen.aov)
> fit <- fitted(RCBDPen.aov, error.term = "Blend:Flask")
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("fitted.aovlist", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("fitted.errors")
> ### * fitted.errors
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: fitted.errors
> ### Title: Extract the fitted values for a fitted model
> ### Aliases: fitted.errors
> ### Keywords: models htest
> 
> ### ** Examples
> 
> ## set up data frame for randomized complete block design in Table 4.4 from 
> ## Box, Hunter and Hunter (2005) Statistics for Experimenters. 2nd edn 
> ## New York, Wiley.
> RCBDPen.dat <- fac.gen(list(Blend=5, Flask=4))
> RCBDPen.dat$Treat <- factor(rep(c("A","B","C","D"), times=5))
> RCBDPen.dat$Yield <- c(89,88,97,94,84,77,92,79,81,87,87,
+                        85,87,92,89,84,79,81,80,88)
> 
> ## perform the analysis of variance
> RCBDPen.aov <- aov(Yield ~ Blend + Treat + Error(Blend/Flask), RCBDPen.dat)
> summary(RCBDPen.aov)

Error: Blend
      Df Sum Sq Mean Sq
Blend  4    264      66

Error: Blend:Flask
          Df Sum Sq Mean Sq F value Pr(>F)
Treat      3     70   23.33   1.239  0.339
Residuals 12    226   18.83               
> 
> ## three equivalent ways of extracting the fitted values
> fit  <- fitted.aovlist(RCBDPen.aov)
> fit <- fitted(RCBDPen.aov, error.term = "Blend:Flask")
> fit <- fitted.errors(RCBDPen.aov, error.term = "Blend:Flask")
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("fitted.errors", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("get.daeTolerance")
> ### * get.daeTolerance
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: get.daeTolerance
> ### Title: Gets the value of daeTolerance for the package dae
> ### Aliases: get.daeTolerance
> ### Keywords: manip projector
> 
> ### ** Examples
> 
> ## get daeTolerance.
> get.daeTolerance()
 element.tol    eigen.tol 
1.490116e-08 1.490116e-08 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("get.daeTolerance", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("harmonic.mean")
> ### * harmonic.mean
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: harmonic.mean
> ### Title: Calcuates the harmonic mean.
> ### Aliases: harmonic.mean
> ### Keywords: manip
> 
> ### ** Examples
> 
> y <- c(seq(0.1,1,0.2))
> harmonic.mean(y)
[1] 0.2797513
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("harmonic.mean", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("interaction.ABC.plot")
> ### * interaction.ABC.plot
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: interaction.ABC.plot
> ### Title: Plots an interaction plot for three factors
> ### Aliases: interaction.ABC.plot
> ### Keywords: aplot hplot design
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ## plot for Example 14.1 from Mead, R. (1990). The Design of Experiments: 
> ##D ## Statistical Principles for Practical Application. Cambridge, 
> ##D ## Cambridge University Press.  
> ##D ## use ?SPLGrass.dat for details
> ##D data(SPLGrass.dat)
> ##D interaction.ABC.plot(Main.Grass, x.factor=Period,
> ##D                      groups.factor=Spring, trace.factor=Summer,
> ##D                      data=SPLGrass.dat,
> ##D                      title="Effect of Period, Spring and Summer on Main Grass")
> ##D 
> ##D ## plot for generated data
> ##D ## use ?ABC.Interact.dat for data set details
> ##D data(ABC.Interact.dat)
> ##D ## Add standard errors for plotting 
> ##D ## - here data contains a single value for each combintion of A, B and C
> ##D ## - need to supply name for data twice 
> ##D ABC.Interact.dat$se <- rep(c(0.5,1), each=4)
> ##D interaction.ABC.plot(MOE, A, B, C, data=ABC.Interact.dat,
> ##D                      ggplotFunc=list(geom_errorbar(data=ABC.Interact.dat, 
> ##D                                                    aes(ymax=MOE+se, ymin=MOE-se), 
> ##D                                                    width=0.2)))
> ## End(Not run)
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("interaction.ABC.plot", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("is.allzero")
> ### * is.allzero
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: is.allzero
> ### Title: Tests whether all elements are approximately zero
> ### Aliases: is.allzero
> ### Keywords: manip
> 
> ### ** Examples
> 
> ## create a vector of 9 zeroes and a one
> y <- c(rep(0,9), 1)
> 
> ## check that vector is only zeroes is FALSE 
> is.allzero(y)
[1] FALSE
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("is.allzero", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("is.projector")
> ### * is.projector
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: is.projector
> ### Title: Tests whether an object is a valid object of class projector
> ### Aliases: is.projector
> ### Keywords: array projector
> 
> ### ** Examples
> 
> ## set up a 2 x 2 mean operator that takes the mean of a vector of 2 values
> m <- matrix(rep(0.5,4), nrow=2)
> 
> ## create an object of class projector
> proj.m <- projector(m)
> 
> ## check that it is a valid projector
> is.projector(proj.m)
[1] TRUE
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("is.projector", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("marginality")
> ### * marginality
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: marginality
> ### Title: Extracts the marginality matrix (matrices) from a
> ###   'pstructure.object' or a 'pcanon.object'.
> ### Aliases: marginality.pcanon marginality.pstructure marginality
> ### Keywords: array design projector
> 
> ### ** Examples
> 
> ## PBIBD(2) from p. 379 of Cochran and Cox (1957) Experimental Designs. 
> ## 2nd edn Wiley, New York
> PBIBD2.unit <- list(Block = 6, Unit = 4)
> PBIBD2.nest <- list(Unit = "Block")
> trt <- factor(c(1,4,2,5, 2,5,3,6, 3,6,1,4, 4,1,5,2, 5,2,6,3, 6,3,4,1))
> PBIBD2.lay <- designRandomize(allocated = trt, 
+                               recipient = PBIBD2.unit, 
+                               nested.recipients = PBIBD2.nest)
> 
> ##obtain pstructure.object and extract marginality matrix
> unit.struct <- pstructure(~ Block/Unit, data = PBIBD2.lay)
> unit.marg <- marginality(unit.struct)
> 
> ##obtain combined decomposition and extract marginality matrices
> unit.trt.canon <- designAnatomy(list(unit=~ Block/Unit, trt=~ trt), data = PBIBD2.lay)
> marg <- marginality(unit.trt.canon)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("marginality", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("mat.I")
> ### * mat.I
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: mat.I
> ### Title: Forms a unit matrix
> ### Aliases: mat.I
> ### Keywords: array
> 
> ### ** Examples
> 
>     col.I <- mat.I(order=4)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("mat.I", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("mat.J")
> ### * mat.J
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: mat.J
> ### Title: Forms a square matrix of ones
> ### Aliases: mat.J
> ### Keywords: array
> 
> ### ** Examples
> 
>     col.J <- mat.J(order=4)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("mat.J", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("mat.Vpred")
> ### * mat.Vpred
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: mat.Vpred
> ### Title: Calculates the variances of a set of predicted effects from a
> ###   mixed model
> ### Aliases: mat.Vpred
> ### Keywords: array design
> 
> ### ** Examples
> 
> ## Reduced example from Smith et al. (2015)
> ## Generate two-phase design
> mill.fac <- fac.gen(list(Mrep = 2, Mday = 2, Mord = 3))
> field.lay <- fac.gen(list(Frep = 2, Fplot = 4))
> field.lay$Variety <- factor(c("D","E","Y","W","G","D","E","M"), 
+                             levels = c("Y","W","G","M","D","E"))
> start.design <- cbind(mill.fac, field.lay[c(3,4,5,8,1,7,3,4,5,8,6,2),])
> rownames(start.design) <- NULL
> 
> ## Set up matrices
> n <- nrow(start.design)
> W <- model.matrix(~ -1+ Variety, start.design)
> ng <- ncol(W)
> Gg<- diag(1, ng)
> Vu <- with(start.design, fac.vcmat(Mrep, 0.3) + 
+                          fac.vcmat(fac.combine(list(Mrep, Mday)), 0.2) + 
+                          fac.vcmat(Frep, 0.1) + 
+                          fac.vcmat(fac.combine(list(Frep, Fplot)), 0.2))
> R <- diag(1, n)
>   
> ## Calculate the variance matrix of the predicted random Variety effects
> Vp <- mat.Vpred(W = W, Gg = Gg, Vu = Vu, R = R)
Warning in mat.Vpred(W = W, Gg = Gg, Vu = Vu, R = R) :
  mat.Vpred is superseded by mat.Vpredicts, being retained for backwards compatibility; it may be deprecated in future versions
> designAmeasures(Vp)
          all
all 0.8564816
> 
> ## Calculate the variance matrix of the predicted fixed Variety effects, 
> ## elminating the grand mean
> Vp.reduc <- mat.Vpred(W = W, Gg = 0, Vu = Vu, R = R, 
+                       eliminate = projector(matrix(1, nrow = n, ncol = n)/n))
Warning in mat.Vpred(W = W, Gg = 0, Vu = Vu, R = R, eliminate = projector(matrix(1,  :
  mat.Vpred is superseded by mat.Vpredicts, being retained for backwards compatibility; it may be deprecated in future versions
> designAmeasures(Vp.reduc)
         all
all 1.521495
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("mat.Vpred", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("mat.Vpredicts")
> ### * mat.Vpredicts
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: mat.Vpredicts
> ### Title: Calculates the variances of a set of predicted effects from a
> ###   mixed model, based on supplied matrices or formulae.
> ### Aliases: mat.Vpredicts
> ### Keywords: array design
> 
> ### ** Examples
> 
> ## Reduced example from Smith et al. (2015)
> ## Generate two-phase design
> mill.fac <- fac.gen(list(Mrep = 2, Mday = 2, Mord = 3))
> field.lay <- fac.gen(list(Frep = 2, Fplot = 4))
> field.lay$Variety <- factor(c("D","E","Y","W","G","D","E","M"), 
+                             levels = c("Y","W","G","M","D","E"))
> start.design <- cbind(mill.fac, field.lay[c(3,4,5,8,1,7,3,4,5,8,6,2),])
> rownames(start.design) <- NULL
> 
> ## Set gammas
> terms <- c("Variety", "Frep", "Frep:Fplot", "Mrep", "Mrep:Mday", "Mrep:Mday:Mord")
> gammas <- c(1, 0.1, 0.2, 0.3, 0.2, 1)
> names(gammas) <- terms
> 
> ## Specify matrices to calculate the variance matrix of the predicted fixed Variety effects 
> W <- model.matrix(~ -1 + Variety, start.design)
> Vu <- with(start.design, fac.vcmat(Mrep, gammas["Mrep"]) + 
+                          fac.vcmat(fac.combine(list(Mrep,Mday)), gammas["Mrep:Mday"]) + 
+                          fac.vcmat(Frep, gammas["Frep"]) + 
+                          fac.vcmat(fac.combine(list(Frep,Fplot)), gammas["Frep:Fplot"]))
> R <- diag(1, nrow(start.design))
>   
> ## Calculate variance matrix
> Vp <- mat.Vpredicts(target = W, random=Vu, R=R)
> 
> ## Calculate the variance matrix of the predicted random Variety effects using formulae
> Vp <- mat.Vpredicts(target = ~ -1 + Variety, Gt = 1, 
+                     fixed = ~ 1, 
+                     random = ~ -1 + Mrep/Mday + Frep/Fplot, 
+                     G = as.list(gammas[c(4,5,2,3)]), 
+                     R = R, design = start.design)
> designAmeasures(Vp)
          all
all 0.8564816
> 
> ## Calculate the variance matrix of the predicted fixed Variety effects, 
> ## elminating the grand mean
> n <- nrow(start.design)
> Vp.reduc <- mat.Vpredicts(target = ~ -1 + Variety, 
+                           random = ~ -1 + Mrep/Mday + Frep/Fplot, 
+                           G = as.list(gammas[c(4,5,2,3)]), 
+                           eliminate = projector(matrix(1, nrow = n, ncol = n)/n), 
+                           design = start.design)
> designAmeasures(Vp.reduc)
         all
all 1.521495
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("mat.Vpredicts", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("mat.ar1")
> ### * mat.ar1
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: mat.ar1
> ### Title: Forms an ar1 correlation matrix
> ### Aliases: mat.ar1
> ### Keywords: array
> 
> ### ** Examples
> 
>     corr <- mat.ar1(rho=0.4, order=4)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("mat.ar1", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("mat.ar2")
> ### * mat.ar2
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: mat.ar2
> ### Title: Forms an ar2 correlation matrix
> ### Aliases: mat.ar2
> ### Keywords: array
> 
> ### ** Examples
> 
>     corr <- mat.ar2(ARparameters = c(0.4, 0.2), order = 4)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("mat.ar2", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("mat.ar3")
> ### * mat.ar3
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: mat.ar3
> ### Title: Forms an ar3 correlation matrix
> ### Aliases: mat.ar3
> ### Keywords: array
> 
> ### ** Examples
> 
>     corr <- mat.ar3(ARparameters = c(0.4, 0.2, 0.1), order = 4)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("mat.ar3", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("mat.arma")
> ### * mat.arma
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: mat.arma
> ### Title: Forms an arma correlation matrix
> ### Aliases: mat.arma
> ### Keywords: array
> 
> ### ** Examples
> 
>     corr <- mat.arma(ARparameter = 0.4, MAparameter = -0.2, order = 4)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("mat.arma", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("mat.banded")
> ### * mat.banded
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: mat.banded
> ### Title: Form a banded matrix from a vector of values
> ### Aliases: mat.banded
> ### Keywords: array
> 
> ### ** Examples
> 
>       m <- mat.banded(c(1,0.6,0.5), 5,5)
>       m <- mat.banded(c(1,0.6,0.5), 3,4)
>       m <- mat.banded(c(1,0.6,0.5), 4,3)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("mat.banded", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("mat.dirprod")
> ### * mat.dirprod
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: mat.dirprod
> ### Title: Forms the direct product of two matrices
> ### Aliases: mat.dirprod
> ### Keywords: array
> 
> ### ** Examples
> 
>     col.I <- mat.I(order=4)
>     row.I <- mat.I(order=28)
>     V <- mat.dirprod(col.I, row.I)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("mat.dirprod", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("mat.dirsum")
> ### * mat.dirsum
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: mat.dirsum
> ### Title: Forms the direct sum of a list of matrices
> ### Aliases: mat.dirsum
> ### Keywords: array
> 
> ### ** Examples
> 
>        m1 <- matrix(1:4, nrow=2)
>        m2 <- matrix(11:16, nrow=3)
>        m3 <- diag(1, nrow=2, ncol=2)
>        dsum <- mat.dirsum(list(m1, m2, m3))
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("mat.dirsum", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("mat.exp")
> ### * mat.exp
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: mat.exp
> ### Title: Forms an exponential correlation matrix
> ### Aliases: mat.exp
> ### Keywords: array
> 
> ### ** Examples
> 
>     corr <- mat.exp(coordinates=c(3:6, 9:12, 15:18), rho=0.1)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("mat.exp", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("mat.gau")
> ### * mat.gau
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: mat.gau
> ### Title: Forms an exponential correlation matrix
> ### Aliases: mat.gau
> ### Keywords: array
> 
> ### ** Examples
> 
>     corr <- mat.gau(coordinates=c(3:6, 9:12, 15:18), rho=0.1)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("mat.gau", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("mat.ma1")
> ### * mat.ma1
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: mat.ma1
> ### Title: Forms an ma1 correlation matrix
> ### Aliases: mat.ma1
> ### Keywords: array
> 
> ### ** Examples
> 
>     corr <- mat.ma1(MAparameter=0.4, order=4)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("mat.ma1", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("mat.ma2")
> ### * mat.ma2
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: mat.ma2
> ### Title: Forms an ma2 correlation matrix
> ### Aliases: mat.ma2
> ### Keywords: array
> 
> ### ** Examples
> 
>     corr <- mat.ma2(MAparameters = c(0.4, -0.2), order = 4)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("mat.ma2", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("mat.ncssvar")
> ### * mat.ncssvar
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: mat.ncssvar
> ### Title: Calculates the variance matrix of the random effects for a
> ###   natural cubic smoothing spline
> ### Aliases: mat.ncssvar
> ### Keywords: array design
> 
> ### ** Examples
> 
> Gs <- mat.ncssvar(knot.points = 1:10)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("mat.ncssvar", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("mat.sar")
> ### * mat.sar
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: mat.sar
> ### Title: Forms an sar correlation matrix
> ### Aliases: mat.sar
> ### Keywords: array
> 
> ### ** Examples
> 
>     corr <- mat.sar(SARparameter = -0.4, order = 4)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("mat.sar", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("mat.sar2")
> ### * mat.sar2
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: mat.sar2
> ### Title: Forms an sar2 correlation matrix
> ### Aliases: mat.sar2
> ### Keywords: array
> 
> ### ** Examples
> 
>     corr <- mat.sar2(gamma = c(-0.4, 0.2), order = 4)
>     corr <- mat.sar2(gamma = c(-0.4, 0.2), order = 4, print = "ar3")
Calculated  parameter values for the associated AR3 process
 0, 0.12, -0.016 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("mat.sar2", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("mpone")
> ### * mpone
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: mpone
> ### Title: Converts the first two levels of a factor into the numeric
> ###   values -1 and +1
> ### Aliases: mpone
> ### Keywords: factor manip
> 
> ### ** Examples
> 
> ## generate all combinations of two two-level factors
> mp <- c("-", "+")
> Frf3.trt <- fac.gen(list(A = mp, B = mp))
> 
> ## add factor C, whose levels are the products of the levles of A and B
> Frf3.trt$C <- factor(mpone(Frf3.trt$A)*mpone(Frf3.trt$B), labels = mp)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("mpone", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("no.reps")
> ### * no.reps
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: no.reps
> ### Title: Computes the number of replicates for an experiment
> ### Aliases: no.reps
> ### Keywords: design
> 
> ### ** Examples
> 
> ## Compute the number of replicates (blocks) required for a randomized 
> ## complete block design with four treatments. 
> no.reps(multiple = 1, df.num = 3,
+         df.denom = expression(df.num * (r - 1)), delta = 5,
+ 	        sigma = sqrt(20), print = TRUE)
        rm df.num df.denom alpha delta    sigma   lambda     powr
1 20.33437      3 58.00311  0.05     5 4.472136 12.70898 0.836116
        rm df.num df.denom alpha delta    sigma   lambda      powr
1 31.66563      3 91.99689  0.05     5 4.472136 19.79102 0.9676862
        rm df.num df.denom alpha delta    sigma   lambda      powr
1 13.33126      3 36.99379  0.05     5 4.472136 8.332039 0.6226844
        rm df.num df.denom alpha delta    sigma   lambda      powr
1 22.64998      3 64.94994  0.05     5 4.472136 14.15624 0.8795446
        rm df.num df.denom alpha delta    sigma   lambda      powr
1 17.65942      3 49.97826  0.05     5 4.472136 11.03714 0.7704095
        rm df.num df.denom alpha delta    sigma   lambda      powr
1 18.62379      3 52.87137  0.05     5 4.472136 11.63987 0.7961913
        rm df.num df.denom alpha delta    sigma   lambda      powr
1 18.92537      3 53.77612  0.05     5 4.472136 11.82836 0.8037564
        rm df.num df.denom alpha delta    sigma  lambda      powr
1 18.77872      3 53.33616  0.05     5 4.472136 11.7367 0.8001066
        rm df.num df.denom alpha delta    sigma   lambda      powr
1 18.74539      3 53.23616  0.05     5 4.472136 11.71587 0.7992694
        rm df.num df.denom alpha delta    sigma   lambda     powr
1 18.81205      3 53.43616  0.05     5 4.472136 11.75753 0.800941
        rm df.num df.denom alpha delta    sigma  lambda      powr
1 18.77872      3 53.33616  0.05     5 4.472136 11.7367 0.8001066
$nreps
[1] 19

$power
[1] 0.8055926

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("no.reps", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("power.exp")
> ### * power.exp
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: power.exp
> ### Title: Computes the power for an experiment
> ### Aliases: power.exp
> ### Keywords: design
> 
> ### ** Examples
> 
> ## Compute power for a randomized complete block design with four treatments 
> ## and five blocks. 
> rm <- 5
> power.exp(rm = rm, df.num = 3, df.denom = 3 * (rm - 1), delta = 5,
+           sigma = sqrt(20),print = TRUE)
  rm df.num df.denom alpha delta    sigma lambda      powr
1  5      3       12  0.05     5 4.472136  3.125 0.2159032
[1] 0.2159032
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("power.exp", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("print.aliasing")
> ### * print.aliasing
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: print.aliasing
> ### Title: Print an aliasing data.frame
> ### Aliases: print.aliasing
> ### Keywords: array projector
> 
> ### ** Examples
> 
> ## Generate a data.frame with 3 factors length 12
> pseudo.lay <- data.frame(pl = factor(1:12),
+                          ab = factor(rep(1:4, times=3)),
+                          a = factor(rep(1:2, times=6)))
> 
> 
> ## create a pstructure object
> trt.struct <- pstructure(~ ab+a, data = pseudo.lay)
Warning in pstructure.formula(~ab + a, data = pseudo.lay) :
  a is aliased with previous terms in the formula and has been removed

Table of (partial) aliasing between terms within a structure

 Source df Alias aefficiency eefficiency order
 a      0  ab         0.0000      0.0000     0
> 
> ## print the object either using the Method function, the generic function or show
> print.aliasing(trt.struct$aliasing)

Table of (partial) aliasing between terms within a structure

 Source df Alias aefficiency eefficiency order
 a      0  ab         0.0000      0.0000     0
> print(trt.struct$aliasing, which.criteria = "none")

Table of (partial) aliasing between terms within a structure

 Source df Alias none
 a      0  ab        
> trt.struct$aliasing

Table of (partial) aliasing between terms within a structure

 Source df Alias aefficiency eefficiency order
 a      0  ab         0.0000      0.0000     0
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("print.aliasing", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("print.projector")
> ### * print.projector
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: print.projector
> ### Title: Print projectors
> ### Aliases: print.projector print,projector-method
> ### Keywords: array projector
> 
> ### ** Examples
> 
> ## set up a 2 x 2 mean operator that takes the mean of a vector of 2 values
> m <- matrix(rep(0.5,4), nrow=2)
> 
> ## create an object of class projector
> proj.m <- projector(m)
> 
> ## print the object either using the Method function, the generic function or show
> print.projector(proj.m)
     [,1] [,2]
[1,]  0.5  0.5
[2,]  0.5  0.5
degfree:  1 
> print(proj.m)
     [,1] [,2]
[1,]  0.5  0.5
[2,]  0.5  0.5
degfree:  1 
> proj.m
     [,1] [,2]
[1,]  0.5  0.5
[2,]  0.5  0.5
degfree:  1 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("print.projector", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("print.pstructure")
> ### * print.pstructure
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: print.pstructure
> ### Title: Prints a pstructure.object
> ### Aliases: print.pstructure
> ### Keywords: array projector
> 
> ### ** Examples
> 
> ## Generate a data.frame with 4 factors, each with three levels, in standard order
> ABCD.lay <- fac.gen(list(A = 3, B = 3, C = 3, D = 3))
> 
> ## create a pstructure object based on the formula ((A*B)/C)*D
> ABCD.struct <- pstructure.formula(~ ((A*B)/C)*D, data =ABCD.lay)
> 
> ## print the object either using the Method function, the generic function or show
> print.pstructure(ABCD.struct)
         df   terms  sources
A         2       A        A
B         2       B        B
A#B       4     A:B      A#B
C[A:B]   18   A:B:C   C[A:B]
D         2       D        D
A#D       4     A:D      A#D
B#D       4     B:D      B#D
A#B#D     8   A:B:D    A#B#D
C#D[A:B] 36 A:B:C:D C#D[A:B]


Marginality matrix

        A B A:B A:B:C D A:D B:D A:B:D A:B:C:D
A       1 0   1     1 0   1   0     1       1
B       0 1   1     1 0   0   1     1       1
A:B     0 0   1     1 0   0   0     1       1
A:B:C   0 0   0     1 0   0   0     0       1
D       0 0   0     0 1   1   1     1       1
A:D     0 0   0     0 0   1   0     1       1
B:D     0 0   0     0 0   0   1     1       1
A:B:D   0 0   0     0 0   0   0     1       1
A:B:C:D 0 0   0     0 0   0   0     0       1


No aliasing between sources in this pstructure object

> print(ABCD.struct)
         df   terms  sources
A         2       A        A
B         2       B        B
A#B       4     A:B      A#B
C[A:B]   18   A:B:C   C[A:B]
D         2       D        D
A#D       4     A:D      A#D
B#D       4     B:D      B#D
A#B#D     8   A:B:D    A#B#D
C#D[A:B] 36 A:B:C:D C#D[A:B]


Marginality matrix

        A B A:B A:B:C D A:D B:D A:B:D A:B:C:D
A       1 0   1     1 0   1   0     1       1
B       0 1   1     1 0   0   1     1       1
A:B     0 0   1     1 0   0   0     1       1
A:B:C   0 0   0     1 0   0   0     0       1
D       0 0   0     0 1   1   1     1       1
A:D     0 0   0     0 0   1   0     1       1
B:D     0 0   0     0 0   0   1     1       1
A:B:D   0 0   0     0 0   0   0     1       1
A:B:C:D 0 0   0     0 0   0   0     0       1


No aliasing between sources in this pstructure object

> ABCD.struct
         df   terms  sources
A         2       A        A
B         2       B        B
A#B       4     A:B      A#B
C[A:B]   18   A:B:C   C[A:B]
D         2       D        D
A#D       4     A:D      A#D
B#D       4     B:D      B#D
A#B#D     8   A:B:D    A#B#D
C#D[A:B] 36 A:B:C:D C#D[A:B]


Marginality matrix

        A B A:B A:B:C D A:D B:D A:B:D A:B:C:D
A       1 0   1     1 0   1   0     1       1
B       0 1   1     1 0   0   1     1       1
A:B     0 0   1     1 0   0   0     1       1
A:B:C   0 0   0     1 0   0   0     0       1
D       0 0   0     0 1   1   1     1       1
A:D     0 0   0     0 0   1   0     1       1
B:D     0 0   0     0 0   0   1     1       1
A:B:D   0 0   0     0 0   0   0     1       1
A:B:C:D 0 0   0     0 0   0   0     0       1


No aliasing between sources in this pstructure object

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("print.pstructure", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("print.summary.p2canon")
> ### * print.summary.p2canon
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: print.summary.p2canon
> ### Title: Prints the values in an 'summary.p2canon' object
> ### Aliases: print.summary.p2canon
> ### Keywords: design projector
> 
> ### ** Examples
> 
> ## PBIBD(2) from p. 379 of Cochran and Cox (1957) Experimental Designs. 
> ## 2nd edn Wiley, New York
> PBIBD2.unit <- list(Block = 6, Unit = 4)
> PBIBD2.nest <- list(Unit = "Block")
> trt <- factor(c(1,4,2,5, 2,5,3,6, 3,6,1,4, 4,1,5,2, 5,2,6,3, 6,3,4,1))
> PBIBD2.lay <- designRandomize(allocated = trt, 
+                               recipient = PBIBD2.unit, 
+                               nested.recipients = PBIBD2.nest)
> 
> ##obtain projectors using pstructure
> unit.struct <- pstructure(~ Block/Unit, data = PBIBD2.lay)
> trt.struct <- pstructure(~ trt, data = PBIBD2.lay)
> 
> ##obtain combined decomposition and print summary
> unit.trt.p2canon <- projs.2canon(unit.struct$Q, trt.struct$Q)
> summ <- summary(unit.trt.p2canon)
> print(summ)


Summary table of the decomposition (based on adjusted quantities)

 Source      Confounded.source df aefficiency eefficiency order
 Block       trt                2      0.2500      0.2500     1
             Residual           3                              
 Unit[Block] trt                5      0.8824      0.7500     2
             Residual          13                              

The design is not orthogonal

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("print.summary.p2canon", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("print.summary.pcanon")
> ### * print.summary.pcanon
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: print.summary.pcanon
> ### Title: Prints the values in an 'summary.pcanon' object
> ### Aliases: print.summary.pcanon
> ### Keywords: design projector
> 
> ### ** Examples
> 
> ## PBIBD(2) from p. 379 of Cochran and Cox (1957) Experimental Designs. 
> ## 2nd edn Wiley, New York
> PBIBD2.unit <- list(Block = 6, Unit = 4)
> PBIBD2.nest <- list(Unit = "Block")
> trt <- factor(c(1,4,2,5, 2,5,3,6, 3,6,1,4, 4,1,5,2, 5,2,6,3, 6,3,4,1))
> PBIBD2.lay <- designRandomize(allocated = trt, 
+                               recipient = PBIBD2.unit, 
+                               nested.recipients = PBIBD2.nest)
> 
> ##obtain combined decomposition and summarize
> unit.trt.canon <- designAnatomy(list(unit=~ Block/Unit, trt=~ trt),
+                                 data = PBIBD2.lay)
> summ <- summary(unit.trt.canon, which = c("aeff","eeff","order"))
> print(summ)


Summary table of the decomposition for unit & trt (based on adjusted quantities)

 Source.unit df1 Source.trt df2 aefficiency eefficiency order
 Block         5 trt          2      0.2500      0.2500     1
                 Residual     3                              
 Unit[Block]  18 trt          5      0.8824      0.7500     2
                 Residual    13                              

The design is not orthogonal

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("print.summary.pcanon", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("proj2.combine")
> ### * proj2.combine
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: proj2.combine
> ### Title: Compute the projection and Residual operators for two, possibly
> ###   nonorthogonal, projectors
> ### Aliases: proj2.combine
> ### Keywords: array design projector
> 
> ### ** Examples
> 
> ## PBIBD(2) from p. 379 of Cochran and Cox (1957) Experimental Designs. 
> ## 2nd edn Wiley, New York
> PBIBD2.unit <- list(Block = 6, Unit = 4)
> PBIBD2.nest <- list(Unit = "Block")
> trt <- factor(c(1,4,2,5, 2,5,3,6, 3,6,1,4, 4,1,5,2, 5,2,6,3, 6,3,4,1))
> PBIBD2.lay <- designRandomize(allocated = trt, 
+                               recipient = PBIBD2.unit, 
+                               nested.recipients = PBIBD2.nest)
> 
> ## obtain sets of projectors
> unit.struct <- pstructure(~ Block/Unit, data = PBIBD2.lay)
> trt.struct <- pstructure(~ trt, data = PBIBD2.lay)
> 
> ## obtain the projection operators for the interblock analysis
> PBIBD2.Bops <- proj2.combine(unit.struct$Q[["Unit[Block]"]], trt.struct$Q[["trt"]])
> Q.B.T <- PBIBD2.Bops$Qconf
> Q.B.res <- PBIBD2.Bops$Qres
> 
> ## demonstrate their orthogonality
> is.allzero(Q.B.T %*% Q.B.res)
[1] TRUE
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("proj2.combine", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("proj2.efficiency")
> ### * proj2.efficiency
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: proj2.efficiency
> ### Title: Computes the canonical efficiency factors for the joint
> ###   decomposition of two projectors
> ### Aliases: proj2.efficiency
> ### Keywords: array design projector
> 
> ### ** Examples
> 
> ## PBIBD(2) from p. 379 of Cochran and Cox (1957) Experimental Designs. 
> ## 2nd edn Wiley, New York
> PBIBD2.unit <- list(Block = 6, Unit = 4)
> PBIBD2.nest <- list(Unit = "Block")
> trt <- factor(c(1,4,2,5, 2,5,3,6, 3,6,1,4, 4,1,5,2, 5,2,6,3, 6,3,4,1))
> PBIBD2.lay <- designRandomize(allocated = trt, 
+                               recipient = PBIBD2.unit, 
+                               nested.recipients = PBIBD2.nest)
> 
> ## obtain sets of projectors
> unit.struct <- pstructure(~ Block/Unit, data = PBIBD2.lay)
> trt.struct <- pstructure(~ trt, data = PBIBD2.lay)
> 
> ## save intrablock efficiencies
> eff.intra <- proj2.efficiency(unit.struct$Q[["Block"]], trt.struct$Q[["trt"]])
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("proj2.efficiency", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("proj2.eigen")
> ### * proj2.eigen
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: proj2.eigen
> ### Title: Canonical efficiency factors and eigenvectors in joint
> ###   decomposition of two projectors
> ### Aliases: proj2.eigen
> ### Keywords: array design projector
> 
> ### ** Examples
> 
> ## PBIBD(2) from p. 379 of Cochran and Cox (1957) Experimental Designs. 
> ## 2nd edn Wiley, New York
> PBIBD2.unit <- list(Block = 6, Unit = 4)
> PBIBD2.nest <- list(Unit = "Block")
> trt <- factor(c(1,4,2,5, 2,5,3,6, 3,6,1,4, 4,1,5,2, 5,2,6,3, 6,3,4,1))
> PBIBD2.lay <- designRandomize(allocated = trt, 
+                               recipient = PBIBD2.unit, 
+                               nested.recipients = PBIBD2.nest)
> 
> ## obtain sets of projectors
> unit.struct <- pstructure(~ Block/Unit, data = PBIBD2.lay)
> trt.struct <- pstructure(~ trt, data = PBIBD2.lay)
> 
> ## obtain intra- and inter-block decompositions
> decomp.inter <- proj2.eigen(unit.struct$Q[["Block"]], trt.struct$Q[["trt"]])
> decomp.intra <- proj2.eigen(unit.struct$Q[["Unit[Block]"]], trt.struct$Q[["trt"]])
> 
> #extract intrablock efficiencies
> decomp.intra$efficiencies
[1] 1.00 1.00 1.00 0.75 0.75
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("proj2.eigen", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("projector-class")
> ### * projector-class
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: projector-class
> ### Title: Class projector
> ### Aliases: projector-class coerce,projector,matrix-method
> ###   coerce<-,projector,matrix-method
> ### Keywords: classes array projector
> 
> ### ** Examples
> 
> showClass("projector")
Class "projector" [package "dae"]

Slots:
                      
Name:    .Data degfree
Class:  matrix integer

Extends: 
Class "matrix", from data part
Class "array", by class "matrix", distance 2
Class "structure", by class "matrix", distance 3
Class "vector", by class "matrix", distance 4, with explicit coerce
> 
> ## set up a 2 x 2 mean operator that takes the mean of a vector of 2 values
> m <- matrix(rep(0.5,4), nrow=2)
> 
> ## create an object of class projector
> proj.m <- projector(m)
> 
> ## check that it is a valid projector
> is.projector(proj.m)
[1] TRUE
> 
> ## create a projector based on the matrix m
> proj.m <- new("projector", data=m)
> 
> ## add its degrees of freedom and print the projector
> degfree(proj.m) <- proj.m
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("projector-class", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("projector")
> ### * projector
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: projector
> ### Title: Create projectors
> ### Aliases: projector
> ### Keywords: array projector
> 
> ### ** Examples
> 
> ## set up a 2 x 2 mean operator that takes the mean of a vector of 2 values
> m <- matrix(rep(0.5,4), nrow=2)
> 
> ## create an object of class projector
> proj.m <- projector(m)
> 
> ## check that it is a valid projector
> is.projector(proj.m)
[1] TRUE
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("projector", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("projs.2canon")
> ### * projs.2canon
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: projs.2canon
> ### Title: A canonical analysis of the relationships between two sets of
> ###   projectors
> ### Aliases: projs.2canon
> ### Keywords: array design projector
> 
> ### ** Examples
> 
> ## PBIBD(2) from p. 379 of Cochran and Cox (1957) Experimental Designs. 
> ## 2nd edn Wiley, New York
> PBIBD2.unit <- list(Block = 6, Unit = 4)
> PBIBD2.nest <- list(Unit = "Block")
> trt <- factor(c(1,4,2,5, 2,5,3,6, 3,6,1,4, 4,1,5,2, 5,2,6,3, 6,3,4,1))
> PBIBD2.lay <- designRandomize(allocated = trt, 
+                               recipient = PBIBD2.unit, 
+                               nested.recipients = PBIBD2.nest)
> 
> ##obtain projectors using pstructure
> unit.struct <- pstructure(~ Block/Unit, data = PBIBD2.lay)
> trt.struct <- pstructure(~ trt, data = PBIBD2.lay)
> 
> ##obtain combined decomposition and summarize
> unit.trt.p2canon <- projs.2canon(unit.struct$Q, trt.struct$Q)
> summary(unit.trt.p2canon)


Summary table of the decomposition (based on adjusted quantities)

 Source      Confounded.source df aefficiency eefficiency order
 Block       trt                2      0.2500      0.2500     1
             Residual           3                              
 Unit[Block] trt                5      0.8824      0.7500     2
             Residual          13                              

The design is not orthogonal

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("projs.2canon", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("projs.combine.p2canon")
> ### * projs.combine.p2canon
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: projs.combine.p2canon
> ### Title: Extract, from a p2canon object, the projectors that give the
> ###   combined canonical decomposition
> ### Aliases: projs.combine.p2canon
> ### Keywords: array design projector
> 
> ### ** Examples
> 
> ## PBIBD(2) from p. 379 of Cochran and Cox (1957) Experimental Designs. 
> ## 2nd edn Wiley, New York
> PBIBD2.unit <- list(Block = 6, Unit = 4)
> PBIBD2.nest <- list(Unit = "Block")
> trt <- factor(c(1,4,2,5, 2,5,3,6, 3,6,1,4, 4,1,5,2, 5,2,6,3, 6,3,4,1))
> PBIBD2.lay <- designRandomize(allocated = trt, 
+                               recipient = PBIBD2.unit, 
+                               nested.recipients = PBIBD2.nest)
> 
> ## obtain sets of projectors
> unit.struct <- pstructure(~ Block/Unit, data = PBIBD2.lay)
> trt.struct <- pstructure(~ trt, data = PBIBD2.lay)
> 
> ##obtain combined decomposition
> unit.trt.p2canon <- projs.2canon(unit.struct$Q, trt.struct$Q)
> UcombineT <- projs.combine.p2canon(unit.trt.p2canon)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("projs.combine.p2canon", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("pstructure.formula")
> ### * pstructure.formula
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: pstructure.formula
> ### Title: Takes a formula and constructs a 'pstructure.object' that
> ###   includes the orthogonalized projectors for the terms in a formula
> ### Aliases: pstructure.formula pstructure
> ### Keywords: array design projector
> 
> ### ** Examples
> 
> ## PBIBD(2) from p. 379 of Cochran and Cox (1957) Experimental Designs. 
> ## 2nd edn Wiley, New York
> PBIBD2.unit <- list(Block = 6, Unit = 4)
> PBIBD2.nest <- list(Unit = "Block")
> trt <- factor(c(1,4,2,5, 2,5,3,6, 3,6,1,4, 4,1,5,2, 5,2,6,3, 6,3,4,1))
> PBIBD2.lay <- designRandomize(allocated = trt, 
+                               recipient = PBIBD2.unit, 
+                               nested.recipients = PBIBD2.nest)
> ## manually obtain projectors for units
> Q.G <- projector(matrix(1, nrow=24, ncol=24)/24)                         
> Q.B <- projector(fac.meanop(PBIBD2.lay$Block) - Q.G)
> Q.BP <- projector(diag(1, nrow=24) - Q.B - Q.G)
> 
> ## manually obtain projector for trt
> Q.T <- projector(fac.meanop(PBIBD2.lay$trt) - Q.G)
> 
> ##compute intrablock efficiency criteria
> effic <- proj2.efficiency(Q.BP, Q.T)
> effic
[1] 1.00 1.00 1.00 0.75 0.75
> efficiency.criteria(effic)
$aefficiency
[1] 0.8823529

$mefficiency
[1] 0.9

$sefficiency
[1] 0.01875

$eefficiency
[1] 0.75

$xefficiency
[1] 1

$order
[1] 2

$dforthog
[1] 3

> 
> ##obtain projectors using pstructure.formula
> unit.struct <- pstructure(~ Block/Unit, data = PBIBD2.lay)
> trt.struct <- pstructure(~ trt, data = PBIBD2.lay)
> 
> ##obtain combined decomposition and summarize
> unit.trt.p2canon <- projs.2canon(unit.struct$Q, trt.struct$Q)
> summary(unit.trt.p2canon, which = c("aeff","eeff","order"))


Summary table of the decomposition (based on adjusted quantities)

 Source      Confounded.source df aefficiency eefficiency order
 Block       trt                2      0.2500      0.2500     1
             Residual           3                              
 Unit[Block] trt                5      0.8824      0.7500     2
             Residual          13                              

The design is not orthogonal

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("pstructure.formula", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("qqyeffects")
> ### * qqyeffects
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: qqyeffects
> ### Title: Half or full normal plot of Yates effects
> ### Aliases: qqyeffects
> ### Keywords: iplot hplot design htest
> 
> ### ** Examples
> 
> ## analysis of 2^4 factorial experiment from Table 10.6 of Box, Hunter and 
> ## Hunter (1978) Statistics for Experimenters. New York, Wiley.
> ## use ?Fac4Proc.dat for data set details
> data(Fac4Proc.dat)
> Fac4Proc.aov <- aov(Conv ~ Catal * Temp * Press * Conc + Error(Runs),
+                                                             Fac4Proc.dat)
> qqyeffects(Fac4Proc.aov, error.term="Runs", data=Fac4Proc.dat)
No effects labelled
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("qqyeffects", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("resid.errors")
> ### * resid.errors
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: resid.errors
> ### Title: Extract the residuals for a fitted model
> ### Aliases: resid.errors
> ### Keywords: models htest
> 
> ### ** Examples
> 
> ## set up data frame for randomized complete block design in Table 4.4 from 
> ## Box, Hunter and Hunter (2005) Statistics for Experimenters. 2nd edn 
> ## New York, Wiley.
> RCBDPen.dat <- fac.gen(list(Blend=5, Flask=4))
> RCBDPen.dat$Treat <- factor(rep(c("A","B","C","D"), times=5))
> RCBDPen.dat$Yield <- c(89,88,97,94,84,77,92,79,81,87,87,
+                        85,87,92,89,84,79,81,80,88)
> 
> ## perform the analysis of variance
> RCBDPen.aov <- aov(Yield ~ Blend + Treat + Error(Blend/Flask), RCBDPen.dat)
> summary(RCBDPen.aov)

Error: Blend
      Df Sum Sq Mean Sq
Blend  4    264      66

Error: Blend:Flask
          Df Sum Sq Mean Sq F value Pr(>F)
Treat      3     70   23.33   1.239  0.339
Residuals 12    226   18.83               
> 
> ## two equivalent ways of extracting the residuals
> res  <- residuals.aovlist(RCBDPen.aov)
> res <- residuals(RCBDPen.aov, error.term = "Blend:Flask")
> res <- resid.errors(RCBDPen.aov)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("resid.errors", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("residuals.aovlist")
> ### * residuals.aovlist
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: residuals.aovlist
> ### Title: Extract the residuals from an aovlist object
> ### Aliases: residuals.aovlist residuals
> ### Keywords: methods models htest
> 
> ### ** Examples
> 
> ## set up data frame for randomized complete block design in Table 4.4 from 
> ## Box, Hunter and Hunter (2005) Statistics for Experimenters. 2nd edn 
> ## New York, Wiley.
> RCBDPen.dat <- fac.gen(list(Blend=5, Flask=4))
> RCBDPen.dat$Treat <- factor(rep(c("A","B","C","D"), times=5))
> RCBDPen.dat$Yield <- c(89,88,97,94,84,77,92,79,81,87,87,
+                        85,87,92,89,84,79,81,80,88)
> 
> ## perform the analysis of variance
> RCBDPen.aov <- aov(Yield ~ Blend + Treat + Error(Blend/Flask), RCBDPen.dat)
> summary(RCBDPen.aov)

Error: Blend
      Df Sum Sq Mean Sq
Blend  4    264      66

Error: Blend:Flask
          Df Sum Sq Mean Sq F value Pr(>F)
Treat      3     70   23.33   1.239  0.339
Residuals 12    226   18.83               
> 
> ## two equivalent ways of extracting the residuals
> res  <- residuals.aovlist(RCBDPen.aov)
> res <- residuals(RCBDPen.aov, error.term = "Blend:Flask")
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("residuals.aovlist", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("rmvnorm")
> ### * rmvnorm
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: rmvnorm
> ### Title: generates a vector of random values from a multivariate normal
> ###   distribution
> ### Aliases: rmvnorm
> ### Keywords: datagen
> 
> ### ** Examples
> 
> ## set up a two-level factor and a three-level factor, both of length 12
> A <- factor(rep(1:2, each=6))
> B <- factor(rep(1:3, each=2, times=2))
> 
> ## generate random values from a multivariate normal for which 
> #the mean is 20 for all variables and 
> #the variance matrix has random effects for factor A, ar1 pattern for B and 
> #residual random variation
> mean <- rep(20, 12)
> V <- fac.vcmat(A, 5) + fac.ar1mat(B, 0.6) + 2*mat.I(12)
> y <- rmvnorm(mean, V)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("rmvnorm", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("set.daeTolerance")
> ### * set.daeTolerance
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: set.daeTolerance
> ### Title: Sets the values of daeTolerance for the package dae
> ### Aliases: set.daeTolerance
> ### Keywords: manip projector
> 
> ### ** Examples
> 
> ## set daeTolerance.
> set.daeTolerance(1E-04, 1E-08)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("set.daeTolerance", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("strength")
> ### * strength
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: strength
> ### Title: Generate paper strength values
> ### Aliases: strength
> ### Keywords: datagen design
> 
> ### ** Examples
> 
> ## Here temperature is a factor with 4*3 = 12 values whose
> ## first 3 values specify the temperatures to be applied in
> ## the 3 runs on the first day, values 4 to 6 specify the
> ## temperatures for the 3 runs on day 2, and so on.
> temperature <- factor(rep(c(80,85,90), 4))
> exp.strength <- strength(nodays = 4, noruns = 3,
+                          temperature = temperature, ident = 0123456)
> 
> ## In this second example, a completely randomized design is generated 
> ## for the same 3 temperatures replicated 4 times. The layout is stored 
> ## in the data.frame called Design.
> Design <- designRandomize(allocated = temperature, 
+                           recipient = list(runs = 12), 
+                           seed = 5847123)
> ## eradicate the unrandomized version of temperature
> remove("temperature")
> 
> ## The 12 temperatures in Design are to be regarded as being assigned to 
> ## days and runs in the same manner as for the first example.
> exp.strength <- strength(nodays = 4, noruns = 3,
+                          temperature = Design$temperature, ident = 0123456)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("strength", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("summary.p2canon")
> ### * summary.p2canon
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: summary.p2canon
> ### Title: Summarize a canonical analysis of the relationships between two
> ###   sets of projectors
> ### Aliases: summary.p2canon summary,p2canon-method
> ### Keywords: array design projector
> 
> ### ** Examples
> 
> ## PBIBD(2) from p. 379 of Cochran and Cox (1957) Experimental Designs. 
> ## 2nd edn Wiley, New York
> PBIBD2.unit <- list(Block = 6, Unit = 4)
> PBIBD2.nest <- list(Unit = "Block")
> trt <- factor(c(1,4,2,5, 2,5,3,6, 3,6,1,4, 4,1,5,2, 5,2,6,3, 6,3,4,1))
> PBIBD2.lay <- designRandomize(allocated = trt, 
+                               recipient = PBIBD2.unit, 
+                               nested.recipients = PBIBD2.nest)
> 
> ##obtain projectors using pstructure
> unit.struct <- pstructure(~ Block/Unit, data = PBIBD2.lay)
> trt.struct <- pstructure(~ trt, data = PBIBD2.lay)
> 
> ##obtain combined decomposition and summarize
> unit.trt.p2canon <- projs.2canon(unit.struct$Q, trt.struct$Q)
> summary(unit.trt.p2canon)


Summary table of the decomposition (based on adjusted quantities)

 Source      Confounded.source df aefficiency eefficiency order
 Block       trt                2      0.2500      0.2500     1
             Residual           3                              
 Unit[Block] trt                5      0.8824      0.7500     2
             Residual          13                              

The design is not orthogonal

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("summary.p2canon", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("summary.pcanon")
> ### * summary.pcanon
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: summary.pcanon
> ### Title: Summarizes the anatomy of a design, being the decomposition of
> ###   the sample space based on its canonical analysis, as produced by
> ###   designAnatomy
> ### Aliases: summary.pcanon summary,pcanon-method
> ### Keywords: array design projector
> 
> ### ** Examples
> 
> ## PBIBD(2) from p. 379 of Cochran and Cox (1957) Experimental Designs. 
> ## 2nd edn Wiley, New York
> PBIBD2.unit <- list(Block = 6, Unit = 4)
> PBIBD2.nest <- list(Unit = "Block")
> trt <- factor(c(1,4,2,5, 2,5,3,6, 3,6,1,4, 4,1,5,2, 5,2,6,3, 6,3,4,1))
> PBIBD2.lay <- designRandomize(allocated = trt, 
+                               recipient = PBIBD2.unit, 
+                               nested.recipients = PBIBD2.nest)
> 
> ##obtain combined decomposition and summarize
> unit.trt.canon <- designAnatomy(list(unit=~ Block/Unit, trt=~ trt), 
+                                 data = PBIBD2.lay)
> summary(unit.trt.canon, which = c("aeff","eeff","order"))


Summary table of the decomposition for unit & trt (based on adjusted quantities)

 Source.unit df1 Source.trt df2 aefficiency eefficiency order
 Block         5 trt          2      0.2500      0.2500     1
                 Residual     3                              
 Unit[Block]  18 trt          5      0.8824      0.7500     2
                 Residual    13                              

The design is not orthogonal

> summary(unit.trt.canon, which = c("aeff","eeff","order"), labels.swap = TRUE)


Summary table of the decomposition for unit & trt (based on adjusted quantities)

 Term.unit  df1 Term.trt df2 aefficiency eefficiency order
 Block        5 trt        2      0.2500      0.2500     1
                Residual   3                              
 Block:Unit  18 trt        5      0.8824      0.7500     2
                Residual  13                              

The design is not orthogonal

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("summary.pcanon", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("tukey.1df")
> ### * tukey.1df
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: tukey.1df
> ### Title: Performs Tukey's one-degree-of-freedom-test-for-nonadditivity
> ### Aliases: tukey.1df
> ### Keywords: models htest
> 
> ### ** Examples
> 
> ## set up data frame for randomized complete block design in Table 4.4 from 
> ## Box, Hunter and Hunter (2005) Statistics for Experimenters. 2nd edn 
> ## New York, Wiley.
> RCBDPen.dat <- fac.gen(list(Blend=5, Flask=4))
> RCBDPen.dat$Treat <- factor(rep(c("A","B","C","D"), times=5))
> RCBDPen.dat$Yield <- c(89,88,97,94,84,77,92,79,81,87,87,
+                        85,87,92,89,84,79,81,80,88)
> 
> ## perform the analysis of variance
> RCBDPen.aov <- aov(Yield ~ Blend + Treat + Error(Blend/Flask), RCBDPen.dat)
> summary(RCBDPen.aov)

Error: Blend
      Df Sum Sq Mean Sq
Blend  4    264      66

Error: Blend:Flask
          Df Sum Sq Mean Sq F value Pr(>F)
Treat      3     70   23.33   1.239  0.339
Residuals 12    226   18.83               
> 
> ## Obtain the quantities for Tukey's test
> tukey.1df(RCBDPen.aov, RCBDPen.dat, error.term = "Blend:Flask")
$Tukey.SS
[1] 2.001082

$Tukey.F
[1] 0.09826791

$Tukey.p
[1] 0.7597822

$Devn.SS
[1] 223.9989

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("tukey.1df", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("yates.effects")
> ### * yates.effects
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: yates.effects
> ### Title: Extract Yates effects
> ### Aliases: yates.effects
> ### Keywords: design htest
> 
> ### ** Examples
> 
> ## analysis of 2^4 factorial experiment from Table 10.6 of Box, Hunter and 
> ## Hunter (1978) Statistics for Experimenters. New York, Wiley.
> ## use ?Fac4Proc.dat for data set details
> data(Fac4Proc.dat)
> Fac4Proc.aov <- aov(Conv ~ Catal * Temp * Press * Conc + Error(Runs),
+                                                             Fac4Proc.dat)
> round(yates.effects(Fac4Proc.aov, error.term="Runs", data=Fac4Proc.dat), 2)
                Catal                  Temp                 Press 
                -8.00                 24.00                 -2.25 
                 Conc            Catal:Temp           Catal:Press 
                -5.50                  1.00                  0.75 
           Temp:Press            Catal:Conc             Temp:Conc 
                -1.25                  0.00                  4.50 
           Press:Conc      Catal:Temp:Press       Catal:Temp:Conc 
                -0.25                 -0.75                  0.50 
     Catal:Press:Conc       Temp:Press:Conc Catal:Temp:Press:Conc 
                -0.25                 -0.75                 -0.25 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("yates.effects", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  15.15 3.14 6.8 NA NA 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
